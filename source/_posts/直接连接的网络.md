layout: postcd ..
title: 直接连接的网络
date: 2016-4-22 13:27:36
tags: 计算机网络
category:
- 网络
---
在节点能够成功的交换分组之前，必须先解决的五个问题。
1. 对传送到铜线等介质上的比特编码(`encoding`)
2. 把在链路上传输的比特序列描述为完整的消息，以便传送到端节点，这称为组帧(`framing`)
3. 传输过程中帧有时候会出现错误，所以有必要检测这类差错并且采取适当的行动，这称为差错检错(`error detection`)
4. 在帧尽管一次又一次出错的情况下，建立一条看起来可靠的链路
5. 在多台主机共享一条链路(而不是用一条简单的点到点链路)的情况下，必须调解对这个链路的访问，这是介质访问控制(`media access control`)
<!-- more -->
## 2.1 网络构件
网络由两类硬件构件组成:节点`node`和链路`link`

### 2.1.1 节点 node
节点是指通用的计算机。为方便介绍，假设节点是工作站类的机器。

#### 网络中最稀缺的两者资源：带宽与内存。
内存之所以是稀缺资源，是因为当一个节点作为交换机或路由器时，分组在等待传输到一个输出链路之前必须在内存中缓存。同时，内存的时延改善速度远远不如CPU，作为一个网络节点，工作站是以其内存速度在运行，而不是CPU速度。

#### 网络适配器
适配器输出一个控制状态寄存器(`control state register`),它对于CPU来说是可读写的。 主机上的软件(设备驱动程序)对CSR写入信息，指示它传送/接收一个帧，并从CSR读出信息获得适配器的当前状态。为了通知主机像收到一帧这样的异步事件，适配器中断主机。

网络适配器最重要的问题之一就是数据字节如何在适配器和主机内存之间传递。 直接存储器访问(`Direct Memory Access,DMA`)和可编程输入输出(Programmed I/O,PIO)。 DMA：适配器直接读写主机内存而不必CPU介入，主机只是给适配器一个内存地址，适配器可读写它。 PIO：CPU直接负责在主机内存与适配器之间传递数据。

### 2.1.2 链路 link
网络链路可用各种不同的物理介质实现。 在点到点链路上通常可用同时传输两个比特流，每个方向一个。这样的链路称为全双工(full-duplex)。一次仅支持数据向一个方向流动的点到点链路，称为半双工(half-duplex)，要求连接到骑上的两个节点轮流使用这条链路。

## 2.2 编码 NRZ,NRZI,Manchester,4B/5B

### NRZ Non-Return to Zero 不归零
将数据值1映射为高电平，数值0映射为低电平。
一长串的0和1导致两个基本问题
第一个问题是导致基线漂移(`baseline wander`)的状态。接收方保持一个它所看到的信号的平均值，然后用这个平均值区分高低电平。
第二个问题是由高到底和由低到高的频繁转换，必须使用时钟恢复(`clock recovery`)。时钟恢复问题就是：编码和解码过程都由一个时钟来驱动，每个时钟周期发送方发送1bit，接收方恢复1bit。为了使接收方能够恢复发送方发送的比特，发送方和接收方的时钟必须精确同步。只要有从1到0货从0到1的跳变，接收方就知道这是在时钟周期的边界上，他能够自己进行重新同步，然而，如果长时期没有这样的跳变就会导致时钟偏移。

### NRZI Non-Return to Zero Inverted 不归零反转
发送方以当前信号的一个跳变编码一个1，以保持当前信号编码一个0。这样就解决了连续1的问题，但是显然未解决连续0的问题。
### Manchester 曼彻斯特编码
通过传输NRZ编码数据与时钟的异或值使时钟与信号明显合并，(把本地时钟看作是一个从低到高变化的内部信号；一对低/高变化的电平看作是一个时钟周期)。注意曼彻斯特编码将0作为一个由低到高的跳变，1作为一个由高到低的跳变。
不过曼彻斯特编码方案存在的问题是它使链路上信号跳变的速率加倍，这就意味着接收方有一半的时间在检测信号的每一个脉冲。信号变化的速率称为链路的波特率(baud rate)。在曼彻斯特编码中，比特率是波特率的一半，所以认为编码的效率仅为50%。
### 4B/5B
这是一种力求不扩大高信号或低信号的持续期而解决曼彻斯特编码的低效问题。4B/5B的思想是在比特流中插入额外的比特打破一连串的0或1。准确的来说，就是用5个bit来编码4个比特的数据，再传送给接收方。5比特代码是由以下方式选定的:每个代码最多有1个前导0，并且末端最多有两个0。由于5比特代码足够用来编码32个不同的代码，因此剩下的16个可用于不同的目的。

## 2.3 组帧
### 2.3.1 面向字节的协议
最早的组帧方法是把每一帧看成一个字节(字符)集，而不是一个比特集。比如PPP与BISYNC。
#### 检测文件结束的两种方法
1. 起止标记法
2. 字节计数法

当要在帧的数据部分出现与起止字符相同的数据时，需要在帧的数据部分插入额外的字符，所以这种方法常备称为字符填充法。
### 2.3.2 面向比特的协议(HDLC)
与面向字节的协议不同，面向比特的协议不关心字节的边界，它只会把帧看成比特的集合。
同样，如果数据部分出现起止控制比特序列，则需要利用比特填充法。
### 2.3.3 基于时钟的组帧(SONET)
略
## 2.4 差错检测
帧中有时会发生比特错误。例如，由于电干扰或热噪音，就会发生这样的错误。
检错只是问题的一部分，另一部分是一发现差错就立即纠错。当消息的接收方检测到差错时，可以采取两种基本方法。一种，是通知发送方消息收到破坏，使发送方能重发消息的副本。如果比特错很少，那么重传的副本很可能没有差错。另一种方法是用集中差错检测算法，他们使接收方即使在消息出错后重新构造正确的消息。这些算法依赖于下面讨论的纠错码(`error-correcting codes`)。

任何差错检测方案的基本思想都是在帧中加入冗余信息来确定是否存在差错。
### 2.4.1 二维奇偶校验
它基于“简单的”（一维）奇偶校验——通常把额外的1比特附加到7比特编码上，来平衡字节中1的个数。例如，奇校验根据字节中1的个数置位第8比特位，使8个比特中1的个数为奇数；而偶校验则置位第8比特位使8个比特中1的个数为偶数。二维奇偶校验对帧中每一字节的每一比特位置进行类似的计算。结果除了每一字节增加1个奇偶校验位外，整个帧产生了一个额外的奇偶校验字节。可以证明，二维奇偶校验可检测所有1、2、3比特错及大部分4比特错。在这种情况下，我们给42比特的消息加入了14比特的冗余信息。
[简单的二维奇偶校验码，也要弄清楚！](http://www.52rd.com/Blog/Detail_RD.Blog_citycenter_14132.html)
### 2.4.2 因特网校验和算法
因特网校验和的思想非常简单——将传输的所有字加起来，然后传输这个相加的结果，此结果称为校验和。接收方对收到的数据执行同样的计算，然后把得到的结果与收到的校验和进行比较。如果传输的任何数据（包括校验和本身）出错，那么结果将不相同，接收方就知道发生了错误。

这个算法比重复编码要好，因为它使用很少的冗余比特，即对任意长度的消息仅用16位，但是它的差错检测能力却不太好。例如，有一对单比特错，一个比特错使一个字增加1，而另一个比特错使另一个字减少1，若两种差错数量相同便无法检测。虽然在检错能力上相对较弱（例如与CRC相比），但我们仍然使用这种算法，原因很简单：这个算法易于用软件实现。ARPANET网的经验表明，这种形式的校验和就足够了。理由是校验和是端到端协议的最后一道防线，大部分差错将由链路层上更强的差错检测算法（如CRC）检查出来。
[网际校验和算法](http://blog.csdn.net/microtong/article/details/3112139)
### 2.4.3 循环冗余校验
略
## 2.5 可靠传输
即使在用纠错码时（例如在无线链路上），某些差错也可能过于严重而无法纠正。因此，某些差错帧必须丢弃。一个想要可靠传输帧的链路层协议必须能以某种方式恢复这些丢弃（丢失）的帧。
通常使用两种基本机制——确认（`acknowledgement`）和超时（`timeout`）的组合来完成上述工作。确认（简称ACK）是协议发给它的对等实体的一个小的控制帧，告知它已收到刚才的帧。所谓控制帧就是一个无任何数据的首部，但是协议也可以将ACK捎带（piggyback）在一个恰好要发向对方的数据帧上。原始帧的发送方收到确认，表明帧发送成功。如果发送方在一段相当长的时间后未收到确认，那么它重传（retransmit）原始帧。等待一段相当长的时间的动作称为超时。
使用确认和超时实现可靠传输的策略有时称为自动请求重发（`Automatic Repeat Request`, ARQ）。
### 2.5.1 停止和等待 stop and wait
发送方传输一帧后，在传输下一帧之前等待一个确认。如果在一段时间之后确认没有到达，则发送方超时，并重传原始帧。
在停止和等待算法中有一个重要的细节，如果发送方发送了一个帧，并且接收方确认它，但这个确认丢失或迟到了。在这两种情况下，发送方超时并重传原始帧，但接收方认为那是下一帧，因为他正确的接收并确认了第帧。这就引起重复传送帧的问题，为解决这个问题，可以在首部包含一比特的序号，即序号可以取0和1，并且每一帧交替使用序号。
缺点：只允许发送方每次在链路上只有一个未确定的帧，这可能远远低于链路的容量。
### 2.5.2 滑动窗口 sliding window
三个任务：
1. 在不可靠的链路上可靠的传输帧
2. 保持帧的传输顺序
3. 流量控制 `flow control`
####  发送方
滑动窗口算法的工作过程如下。首先，发送方对每一帧赋予一个序号（`sequence number`），记作`SeqNum`。现在，忽略`SeqNum`是由有限大小的首部字段实现的事实，而假设它能无限增大。发送方维护三个变量：发送窗口大小（`send window size`），记作SWS，给出发送方能够发送但未确认的帧数的上界；LAR表示最近收到的确认帧（`last acknowledgement received`）的序号；LFS表示最近发送的帧（`last frame sent`）的序号。发送方还遵循如下的不等式：

`LFS－LAR≤SWS`
#### 接收方
当确认到达时，发送方向右移动LAR，从而允许发送方发送另一帧。同时，发送方为所发的每个帧设置一个定时器，如果定时器在接收到ACK之前超时，则重传此帧。注意，发送方必须最多能缓存SWS个帧，因为在它们得到确认之前必须准备重传。

接收方维护下面三个变量：接收窗口大小（`receive window size`），记为RWS，给出接收方所能接收的无序帧数目的上界；LAF表示最大的可接收帧（`largest acceptable frame`）的序号；LFR表示最后收到的帧（`last frame received`）的序号。接收方也遵循如下不等式：

`LAF－LFR≤RWS`

### 2.5.3 并发逻辑信道 concurrent logical channels
在一个点到点的链路上多路复用多个逻辑信道，并且在每个逻辑信道上运行停止和等待算法。在任意逻辑信道上传输的帧之间没有任何关系，同时，因为在每个逻辑信道上可以有一个不同的待确认帧，所以发送方可保持链路满载。
更准确的说，发送方为每一信道状态留3个比特：一个布尔量，说明信道当前是否忙；一比特序号，用于说明下次在这个逻辑信道上发送的帧的序号；以及下一帧的序号，用于说明期望到达这一信道的一个帧的序号。
当节点有一个帧要发送时，它使用序号最小的空闲信道，其他方面表现就和停止和等待一样。

## 2.6 以太网
以太网是一个正在使用的，更通用的带冲突检测的载波监听多路访问局域网技术的例子。(CSMA/CD)
### 2.6.1 物理特性
以太网是在一个长度最高可达500m的同轴电缆上实现的。
多个以太网可以由中继器(repeater)连接起来，中继器是一个转发数字信号的设备，很像转发模拟信号的放大器。然而在任一对主机之间最多可以安装4个中继器，这意味着以太网总共只能达到2500m。以太网最多支持1024台主机。
一个主机送到以太网上的任何信号都是向全网广播的，即信号在两个方向传播，并由中继器将信号转发到所有输出网段。连接到每一网段末端的终结器吸收信号并阻止它反射而干扰到后继的信号。
以太网使用之前提到的曼彻斯特编码。
### 2.6.2 访问协议
控制访问共享以太网链路的算法——以太网的介质访问控制(Media Access Control,MAC)。通常在网络适配器上以硬件的方式实现。
#### 帧格式
| 64bit    | 48bit     |48bit |16bit|46-1500byte| 32bit|
| :------------- | :------------- |
|前同步码  | 目的地址      | 源地址| 类型|帧体|CRC|
#### 地址
以太网上的每台主机都有一个唯一的以太网地址。从技术上来说，地址属于适配器而不是主机，通常固话在ROM中，以可读的方式显示，即由冒号分隔的6个数，每个数字对应于6字节地址的一个字节，并且由一对16进制数给出。
#### 发送器算法
线路一空闲就立即发送(`1-persistant`)
当个两个适配器同时开始传输则两个或多个帧在网上冲突(`collide`)。因为以太网支持冲突检测，所以每个发送方能确定冲突的发生。当适配器检测出自己的帧与其他帧冲突时，它首先确保传输32位干扰序列，然后停止传输。因此，发送器在冲突的情况下将最少发送96位：64位前同步码加32位干扰序列。

一旦适配器检测到冲突并停止传输，它会等待一定的时间后再尝试。在每次尝试发送但失败后，适配器把等待时间加倍，然后再试。每次使重传尝试间的延迟间隔加倍的策略，一般称为指数退避（exponential backoff）技术。
## 2.7 环网 802.5,FDDI,rpr
环网和以太网有两个共同的重要特征：第一，它包括一个分布式算法，控制每个节点何时可以传输；第二，所有的节点一般可以看到所有的帧，帧流过时，在帧首部中标识为目的的节点保留一个该帧的副本。

环网早期最常见的形式都令牌(`token`)环。当一个有帧要传输的节点看到令牌时，它把令牌从环上取下，而将直接的帧插入环中。沿路的每个节点简单的转发帧，目的节点保存帧的副本，然后将消息转发给环的下一个节点，当帧返回到发送方时，这个节点将帧取下，然后再插入令牌。
以这种方式， 某个下游的节点将有机会发送一个帧，介质访问算法是公平的，因为令牌绕着环循环，每个节点都有机会发送帧，令牌环以轮转的方式为节点提供服务。

使用环拓扑，任何链路或节点的故障会造成整个网络的失效。该问题通过使用一个机电中继器将每个站点连接到环上来解决。多站访问单元(MSAU)

### 2.7.1 令牌环介质访问控制
令牌包含一个3比特的优先级字段，因此，我们可以认为令牌在任何时候都有某个优先级n。希望发送分组的每个设备给该分组制定一个优先级。帧首部使用3个保留比特来改变令牌的优先级。

发送方可以在发送帧之后立刻将令牌放回环上(这称为提前释放`early release`)，或者在发送的帧绕环一周冰杯删除后再交回令牌(这称为延迟释放`delayed release`)。
### 2.7.2 令牌环维护
每个令牌环都有一个指定的站点作为监控站(`monitor`)。监控站的作用是确保环的状态良好。环上的任意站都可以成为监控站，当环第一次建立起来或者当前的监控站出现故障时，将由已定义的过程选出监控站。状态良好的监控站用一个特殊的控制消息定期通告它的存在，如果一个站点在一段时间内没有看到这种消息，就假设监控站出现了故障并试图成为监控站。(采用“最高地址获胜”类似的某个定义好的规则来决定)。
### 2.7.3 FDDI
由双环构成：两个独立的环以相反方向传输数据。第二个环正常情况下不使用，仅当主环发生故障时启用。
### 2.7.4 弹性分组环 RPR
弹性(从链路或节点故障中快速回复的能力)是一个关键的设计目标，这使得该技术特别适合于服务提供者网络。
不使用令牌，而使用一种被称为缓冲插入(buffer insertion)的技术。
