{"meta":{"title":"小前端FE","subtitle":"Small Front End","description":"SEF是Small Front End的缩写。 Small表示我们一群新人的面貌。 我们是一群想搞事情的前端新人。","author":"小前端","url":"http://blog.smallsfe.com"},"pages":[{"title":"","date":"2017-02-06T14:52:44.000Z","updated":"2017-02-06T14:52:44.000Z","comments":true,"path":"member/index.html","permalink":"http://blog.smallsfe.com/member/index.html","excerpt":"","text":"SFE成员团队起源最初，是由 DarkZone 创立了“小前端”QQ群，汇聚了一帮初入前端的萌新。于日常群聊中，渐渐的形成了一个小圈子，Jeri 便专门拉了一个微信闲聊群分散水军火力。渐渐的大家越走越近，最后我们这10个萌新一起喊出了“小前端，搞事情”。萌新们都是15-17届应届毕业生。虽然稚嫩，但是也想一起搞点事情，希望能够共同成长，相互促进，同时如果能够帮助更多萌新成长就更好了。 团队组成DarkZone 绰号“大大”人生如戏，本科测绘工程，研究生地理信息工程，毕业在网易做了一名前端，庆幸最后找到了自己喜欢的事情，庆幸认识了一群志同道合的小前端们~ JeriJeri，2016年硕士毕业于武汉大学，并进入腾讯云工作，担任前端工程师一职。热爱生活，喜欢接触新技术、新事物，希望活出自己想要的模样！ 海歌 绰号“hg”神一样的男人，属于未来的框架hg.js创始人。目前就职于腾讯浏览器。 小羊一只安静的小羊,就职于饿了么。 逸飞2016年毕业于东北大学，现在在头条做一名前端。新的一年保持对技术的热情，与大家一起折腾下去 小草 绰号“幸福草”美团最萌前端程序媛。毕业于南京师范大学，在一个妹纸居多的部门哟~想加入的欢迎联系我，我的邮箱1973895060@qq.com Air踩着前端末班车转行入坑的新人一枚，跟着楼上的同志一起做爱做的事，就职于同花顺。 灵儿 人送外号 “上海滩一姐”灵儿，华东师范大学软件工程，本科毕业在点评做了一名前端。喜欢文字，希望能在喜欢的行业做出一些成绩，每天遇见更好的自己。 Yanis本科武大测绘工程，半路转行程序猿，本科毕业在美团做一名前端，萌新一只。 WilsonLiu 绰号：“刘总” or “小盛”一只半路出家野生程序猿，就职于腾讯理财通。 座右铭：致力于做一个有故事的人。小时候听爸爸说他的故事，长大了去创造自己的故事；当父亲后有故事可讲；老了以后有故事可以回味。"},{"title":"","date":"2017-01-25T03:01:19.000Z","updated":"2017-01-25T03:01:19.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.smallsfe.com/about/index.html","excerpt":"","text":"关于SFESFE是谁SEF是Small Front End的缩写。 Small表示我们一群新人的面貌。我们是一群想搞事情的前端萌新。 SFE的愿景作为前端萌新，一起共同成长，互相督促进步，聚在SFE下，一起搞点事情。 SFE的大事记 2017.1.9日 小羊建立github组织，我们发愿将SFE建设为一个搞事情的团队。 2017.1.10日 WilsonLiu贡献组织logo 2017.1.11日 在灵儿的筛选下确定组织博客主题 2017.1.13日 启用新的域名smallsfe.com,博客采用blog.smallsfe.com 2017.1.22日 小前端FE公众号注册成功，由此各个媒体平台都建立了相应的官方账号 2017.1.23日 由灵儿发布小前端博客的第一篇博文 小白文艺程序媛的进阶之路SFE的发展组织基本法全体成员共同努力为SFE的发展共享自己的力量，与此同时以更高的组织标准要求自己进步成长，与优秀的萌新们一起合作积极的搞事情。组织发展的三个方面清单 博客 (组织日常对外的最重要输出) 工具 (前端组件，类库，框架等) 项目 (具体某一个工程项目，诸如一个记录每日工作时间的微信小程序) 博客博客是SFE对外最重要的输出之一，为了规范组织的运行，博客的运营将由专人负责运营。SFE的成员有需要发布的文章请联系运营人员，提供相应文章(只支持markdown格式的文章)。运营人员只负责基本的发布，并没有义务也没有权利对文章进行修改，因此文章的格式请文章的作者自己好好把关。 当前运营负责人: WilsonLiu SFE各个媒体及论坛注册时须统一面貌如下：名称：小前端FE账号：smallsfe 自有媒体 微博：http://weibo.com/smallsfe 微信公众号： 小前端FE(smallsfe) SFE博客http://blog.smallsfe.com QQ: 1926213114 email: sfegsq@qq.com 第三方论坛地址 segmentfault专栏： https://segmentfault.com/blog/smallsfe CSDN专栏： http://blog.csdn.net/smallsfe 工具(待完善)工具的开发采用完全自由的方式，个人开发。在SFE中建立自己的repository，工具希望处于前端领域。 项目(待完善)考虑到项目的开发会涉及到整个产品流程，建议由SFE中一人牵头，至少组织中2人以上进行协作，同时建议邀请有兴趣的朋友共同参与。"}],"posts":[{"title":"如何使用ES6中的参数","slug":"如何使用ES6中的参数","date":"2017-03-07T01:14:12.000Z","updated":"2017-03-07T01:22:39.000Z","comments":true,"path":"2017/03/07/如何使用ES6中的参数/","link":"","permalink":"http://blog.smallsfe.com/2017/03/07/如何使用ES6中的参数/","excerpt":"","text":"ECMAScript 6（或者叫 ECMAScript 2015）是 ECMAScript 的最新标准，极大的提高了 JavaScript 中处理参数的能力。现在我们可以使用 rest 参数（rest parameters）、默认值（default values）和解构（destructuring）以及其他许多新的特性。本文我们将探索参数(arguments)和参数(parameter)的方方面面，看一下ES6是如何对他们改进和提升的。 Arguments 和 Parametersarguments 和 Parameters 的含义通常是可以互换的。尽管如此，为了本文的目标，还是要做出区分。在大多数的标准中，函数声明时给出的叫做 parameters（或者叫 formal parameters），而传递给函数的叫做的 arguments（或者叫 actual arguments），看下面的函数： 1234function foo(param1, param2) &#123; // do something&#125;foo(10, 20); 在这个函数中，param1 和 param2 是函数的 parameters，而传递给函数的值（10 和 20）是 arguments。 译者注：本文后面不再区分 arguments 和 parameters，统一译作参数。:joy: 扩展运算符（…)在 ES5 中，apply() 方法可以很方便将数组作为参数传递给函数，经常用于使用 Math.max() 来取得数组的最大值。看下面的代码段： 123var myArray = [5, 10, 50];Math.max(myArray); // Error: NaNMath.max.apply(Math, myArray); // 50 Math.max() 方法不支持数组，只接受数字作为参数。当数组传递给函数，函数会抛出错误。但是当使用 apply() 方法后，数组变成了一个个单独的数组传递给了函数，所以 Math.max() 就能够正确的执行了。 幸运的是，ES6 给我们带来了扩展运算符，我们就不必再继续使用 apply() 方法了。我们可以将表达式轻松的展开为多个参数。 12var myArray = [5, 10, 50];Math.max(...myArray); // 50 在这里我们通过扩展运算符将 myArray 展开成了一个个单独的值。虽然 ES5 中我们可以通过 apply() 方法来模拟扩展运算符，但是语法上让人迷惑，并且缺少可扩展性。扩展运算符不仅易于使用，还带来了许多新的特性。比如，你可以在函数调用时多次使用扩展运算符，并且还可以和其他参数混合在一起。 1234567function myFunction() &#123; for(var i in arguments)&#123; console.log(arguments[i]); &#125;&#125;var params = [10, 15];myFunction(5, ...params, 20, ...[25]); // 5 10 15 20 25 扩展运算符另一大好处就是他可以很容易的和构造函数（constructor）一起使用： 1new Date(...[2016, 5, 6]); // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time) 当前我们可以使用 ES5 来重写上面的代码，不过我们需要一个复杂的方法来避免一个类型错误： 12new Date.apply(null, [2016, 4, 24]); // TypeError: Date.apply is not a constructornew (Function.prototype.bind.apply(Date, [null].concat([2016, 5, 6]))); // Mon Jun 06 2016 00:00:00 GMT-0700 (Pacific Daylight Time) REST 参数rest 参数和扩展运算符是一样的语法，但是他不是将数组展开成一个个的参数，而是将一个个参数转换为数组。 译者注：rest 参数和扩展运算符虽然一样的语法，在这里你就可以看出作者强调的 arguments 和 parameters 的区别了。扩展运算符用于函数调用的参数（arguments）中，而 rest 参数用于函数声明的参数（parameters）中。 1234function myFunction(...options) &#123; return options;&#125;myFunction('a', 'b', 'c'); // [\"a\", \"b\", \"c\"] 如果没有提供参数，rest 参数会被设置为空数组： 1234function myFunction(...options) &#123; return options;&#125;myFunction(); // [] 当创建可见函数（接受数量可变的参数的函数）的时候，rest 参数就显得十分有用。因为 rest 参数是一个数组，所以可以很方便的替换 arguments 对象（将会在下文讨论）。看下面一个使用 ES5 编写的方法： 123456789function checkSubstrings(string) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; if (string.indexOf(arguments[i]) === -1) &#123; return false; &#125; &#125; return true;&#125;checkSubstrings('this is a string', 'is', 'this'); // true 这个函数的作用是检查一个字符串是否包含指定的一系列字符串。这个函数的第一个问题就是，我们必须查看函数体才知道函数接受多个参数。另外 arguments 的迭代必须从 1 开始，因为 arguments[0] 是第一个参数。如果我们稍后给第一参数之后再添加参数，或许我们就忘记更新这个循环了。使用 rest 参数，我们可以很轻易的避开这个问题： 123456789function checkSubstrings(string, ...keys) &#123; for (var key of keys) &#123; if (string.indexOf(key) === -1) &#123; return false; &#125; &#125; return true;&#125;checkSubstrings('this is a string', 'is', 'this'); // true 函数的输出和上一个函数一样。再重复一次，string 参数作为第一个参数传入，剩下的参数被塞进一个数组并且赋值给了变量 keys。 使用 rest 参数代替 arguments 不仅提高了代码的可读性，并且避免了 JavaScript 中的性能问题。尽管如此，rest 参数并不能无限制使用，举个例子，它只能是最后一个参数，否则会导致语法错误。 1234function logArguments(a, ...params, b) &#123; console.log(a, params, b);&#125;logArguments(5, 10, 15); // SyntaxError: parameter after rest parameter 另一个限制方法声明时只允许一个 rest 参数： 123function logArguments(...param1, ...param2) &#123;&#125;logArguments(5, 10, 15); // SyntaxError: parameter after rest parameter 默认值ES5 中的默认参数ES5 中 JavaScript 并不支持默认值，但这里有个很简单的实现，使用 OR运算符（||），我们可以很容易的模拟默认参数，看下面的代码： 12345678function foo(param1, param2) &#123; param1 = param1 || 10; param2 = param2 || 10; console.log(param1, param2);&#125;foo(5, 5); // 5 5foo(5); // 5 10foo(); // 10 10 这个函数期望接收两个参数，但当无参数调用时，它会使用默认值。在函数内，缺失的参数自动设置为 undefined，所以我们检查这些参数，并给他们设置默认值。为了检测缺失的参数并设置默认值，我们使用 OR 运算符（||）。这个运算符首先检查第一个值，如果是 truthy，运算符会返回它，否则返回第二个参数。 这种方法在函数内很常用，但也存在瑕疵。如果传递 0 或者 null 也会返回默认值。因为它们被认为是 falsy 值。所以如果我们确实需要给函数传递 0 或者 null，我们需要换种方法来检测参数是否缺失： 1234567891011function foo(param1, param2) &#123; if(param1 === undefined)&#123; param1 = 10; &#125; if(param2 === undefined)&#123; param2 = 10; &#125; console.log(param1, param2);&#125;foo(0, null); // 0, nullfoo(); // 10, 10 在这个函数中，通过检查参数的类型是否为 undefined 来确定是否要赋予默认值。这种方法代码量稍微大一些，但更安全，可以让我们给函数传递 0 或者 null。 ES6 中的默认参数ES6 中，我们不必再检查参数是否为 undefined 来模拟默认参数，我们可以直接将默认参数函数声明中。 12345function foo(a = 10, b = 10) &#123; console.log(a, b);&#125;foo(5); // 5 10foo(0, null); // 0 null 正如你所看到的，忽略参数返回了默认值，但传递 0 或者 null 并没有。我们甚至可以使用函数来产生参数的默认值： 123456789function getParam() &#123; alert(\"getParam was called\"); return 3;&#125;function multiply(param1, param2 = getParam()) &#123; return param1 * param2;&#125;multiply(2, 5); // 10multiply(2); // 6 (also displays an alert dialog) 需要注意的是，只有缺少第二个参数的时候，gegParam 方法才会执行，所以当我们使用两个参数 multiply() 的时候并不会弹出 alert。 默认参数另一个有意思的特性是在方法声明是可以引用其他参数和变量作为默认参数： 123456function myFunction(a=10, b=a) &#123; console.log('a = ' + a + '; b = ' + b);&#125;myFunction(); // a=10; b=10myFunction(22); // a=22; b=22myFunction(2, 4); // a=2; b=4 甚至可以在函数声明的时候执行操作符： 1234function myFunction(a, b = ++a, c = a*b) &#123; console.log(c);&#125;myFunction(5); // 36 注意：不像其他语言，JavaScript 是在调用时才计算默认参数的： 123456function add(value, array = []) &#123; array.push(value); return array;&#125;add(5); // [5]add(6); // [6], not [5, 6] 解构赋值解构赋值是 ES6 的新特性，让我们可以从数组或者对象中提取值并赋值给变量，语法上类似于对象和数组字面量。当给函数传参时，这种语法清晰且易于理解并且很实用。 在 ES5 中，经常使用配置对象来处理大量的的可选参数，尤其是属性的顺序无关紧要的时候，看下面的函数： 123456789101112131415161718function initiateTransfer(options) &#123; var protocol = options.protocol, port = options.port, delay = options.delay, retries = options.retries, timeout = options.timeout, log = options.log; // code to initiate transfer&#125;options = &#123; protocol: 'http', port: 800, delay: 150, retries: 10, timeout: 500, log: true&#125;;initiateTransfer(options); 这种模式 JavaScript 开发者经常使用，并且很好用。但我们必须进入函数体内才知道到底需要多少参数，使用解构参数赋值，我们可以在函数声明时很清晰的指定需要的参数。 123456789101112function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125;) &#123; // code to initiate transfer&#125;;var options = &#123; protocol: 'http', port: 800, delay: 150, retries: 10, timeout: 500, log: true&#125;initiateTransfer(options); 在这个函数中，我们使用了对象解构模式，而不是一个配置型对象，让我们的代码更加清晰易读。 我们也可以混用解构参数和普通参数： 1234function initiateTransfer(param1, &#123;protocol, port, delay, retries, timeout, log&#125;) &#123; // code to initiate transfer&#125;initiateTransfer('some value', options); 需要注意，如果函数调用时解构参数缺失会抛出一个类型错误： 1234function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125;) &#123; // code to initiate transfer&#125;initiateTransfer(); // TypeError: Cannot match against 'undefined' or 'null' 当我们的参数是必须的，这种行为我们是想要的，但是如果我们期望参数可选呢？为阻止这种错误，我们需要给解构参数赋一个默认值： 1234function initiateTransfer(&#123;protocol, port, delay, retries, timeout, log&#125; = &#123;&#125;) &#123; // code to initiate transfer&#125;initiateTransfer(); // no error 在这个函数中，我们给解构参数赋了一个空对象作为默认值。现在如果函数调用时没有赋予参数，不会抛出错误。 我们也可以给解构参数每个属性都赋默认值： 12345678910function initiateTransfer(&#123; protocol = 'http', port = 800, delay = 150, retries = 10, timeout = 500, log = true&#125;) &#123; // code to initiate transfer&#125; 在这个例子中，每个属性都被赋予默认值，就无需在函数体内手动检查 undefined 的参数再赋予默认值。 参数传递函数传参有两种方式：引用传递和值传递。如果是引用传递，修改参数会引起全局的变化，如果是值传递，只会引起函数内的变化。 在一些语言中，像 Visual Basic 和 PowerShell，我们可以选择声明是值传递还是引用传递，但 JavaScript 不是这样。 值传递严格来说，JavaScript只能值传递。当我们通过值传递给函数传参，就在函数作用域内创建了这个值得副本。所以任何值得变化都只会反映在函数内部。看下面的例子： 1234567var a = 5;function increment(a) &#123; a = ++a; console.log(a);&#125;increment(a); // 6console.log(a); // 5 在这里，在函数内部修改修改参数并不会影响到原始值。所以在函数外打印这个变量，得到的结果始终是 5。 引用传递在 JavaScript 中，所有的都是值传递，但是当我们传递一个变量指向一个对象（包括数组），这个“值”就指向了这个对象，改变了对象的某个属相也会引起其关联对象的改变。 看这个函数： 123456789function foo(param)&#123; param.bar = 'new value';&#125;obj = &#123; bar : 'value'&#125;console.log(obj.bar); // valuefoo(obj);console.log(obj.bar); // new value 正如你看到的，对象的属性在函数体内部被修改，但是却影响到了函数外部的对象。 当我们传递一个非原始的值，像数组或者对象，程序会在内存中创建一个对象，指向原始地址。如果被修改，原始值也会随之修改。 类型检查和缺失或多余参数在强类型的语言中，我们必须在函数声明时声明参数的类型，但 JavaScript 中没有这种特性，在 JavaScript 中，并不关心传递给函数的参数的类型和个数。 假设我们有一个函数，仅接受一个参数。当我们调用这个函数的使用，我们并不限制到底传递给函数多少个参数，甚至可以选择不传，都不会产生错误。 参数的个数可以分为两种情况： 参数缺失缺失的变量赋值为 undefined 参数过多多余的参数会被忽略，但可以从 arguments 变量中取到（下文即将讨论）。 强制参数函数调用中如果函数缺失，它会被设置为 undefined。我们可以利用这一点，如果参数缺失就抛出错误： 12345function foo(mandatory, optional) &#123; if (mandatory === undefined) &#123; throw new Error('Missing parameter: mandatory'); &#125;&#125; 在 ES6 中，我们可以更近一步，使用默认参数来设置强制参数： 12345678function throwError() &#123; throw new Error('Missing parameter');&#125;function foo(param1 = throwError(), param2 = throwError()) &#123; // do something&#125;foo(10, 20); // okfoo(10); // Error: missing parameter arguments 对象在 ES4 的时候默认参数就被加入，来代替 arguments 对象，但 ES4 并没有实现。随着 ES6 的发布，JavaScript 现在官方支持了默认参数。但并没有取消支持 arguments 的计划。 arguments 对象是一个类数组的对象，可以在所有的函数中取到。arguments 通过数字索引来获取传入的参数，而不是通过参数的名字。这个对象允许我们给函数传入任意多的参数。看下面的代码判断： 123456function checkParams(param1) &#123; console.log(param1); // 2 console.log(arguments[0], arguments[1]); // 2 3 console.log(param1 + arguments[0]); // 4&#125;checkParams(2, 3); 这个函数期望传入一个参数，当我们传入两个参数调用它的时候，我们通过 param1 或者 arguments[0] 来获取第一个参数，但第二个参数只能通过 arguments[1] 获取。也即是说，arguments 对象可以和有命名的参数一起使用。 arguments 对象包含了所有传入函数的参数，并且索引的起始是 1。当我们希望获取更多的参数的时候，我们会使用 arguments[2] 、arguments[3] 等等。 我们可以跳过所有的参数命名设置，仅仅使用 arguments 对象： 1234function checkParams() &#123; console.log(arguments[1], arguments[0], arguments[2]);&#125;checkParams(2, 4, 6); // 4 2 6 实际上，命名的参数是一种方便，但不是必需的。同样的，rest 参数也可以用来显示传入的参数： 12345function checkParams(...params) &#123; console.log(params[1], params[0], params[2]); // 4 2 6 console.log(arguments[1], arguments[0], arguments[2]); // 4 2 6&#125;checkParams(2, 4, 6); arguments 对象是一个类数组对象，但是缺少像 slice 和 foreach 等方法。为了在 arguments 对象上使用这些方法，需要将其转换为真实的数组： 12345function sort() &#123; var a = Array.prototype.slice.call(arguments); return a.sort();&#125;sort(40, 20, 50, 30); // [20, 30, 40, 50] 在这个函数中，使用 Array.prototype.slice.call() 快速将 arguments 对象转换为数组。然后使用 sort 方法进行排序。 ES6 有一种更直接的方法，Array.from()，ES6 新增的方法，用来通过类数组对象创建一个新的数组。 12345function sort() &#123; var a = Array.from(arguments); return a.sort();&#125;sort(40, 20, 50, 30); // [20, 30, 40, 50] length 属性虽然 arguments 对象并不是严格意义的数组，但它有一个 length 属性，可以用来检查传递给函数的参数的个数。 12345function countArguments() &#123; console.log(arguments.length);&#125;countArguments(); // 0countArguments(10, null, \"string\"); // 3 通过使用 length 属性，我们可以更好的控制参数的数量。比如说，如果一个函数需要两个参数，我们就可以使用 length 属性来检查参数数量，如果少于期望数量就抛出错误。 1234567function foo(param1, param2) &#123; if (arguments.length &lt; 2) &#123; throw new Error(\"This function expects at least two arguments\"); &#125; else if (arguments.length === 2) &#123; // do something &#125;&#125; rest 参数是数组，所以他也有 length 属性，我们用 ES6 来重写上面的方法： 1234567function foo(...params) &#123; if (params.length &lt; 2) &#123; throw new Error(\"This function expects at least two arguments\"); &#125; else if (params.length === 2) &#123; // do something &#125;&#125; Callee 和 Caller 属性callee 属性指向当前正在运行的函数，而 caller 指向调用当前正在运行函数的函数。在 ES5 严格模式下，这些属性是被废弃掉的，如果要访问它们会抛出错误。 arguments.callee 属性在递归函数（递归函数是一个普通函数，通过它的签名指向自身）下很有用，尤其是函数的签名不可用时（也就是匿名函数）。因为匿名函数没有名字，唯一指向自身的方法就是通过 arguments.callee。 1234567var result = (function(n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return n * arguments.callee(n - 1); &#125;&#125;)(4); // 24 严格模式和非严格模式下的 arguments在 ES5 非严格模式下， arguments 对象有一个不常用的特性：它保持和命名参数值同步。 1234567function foo(param) &#123; console.log(param === arguments[0]); // true arguments[0] = 500; console.log(param === arguments[0]); // true return param&#125;foo(200); // 500 在函数内部，一个新的值赋给 arguments[0]。因为 arguments 一直和命名参数的值保持同步，arguments[0] 的改变也会引起 param 的改变。事实上，他们是同个变量的不同名称。在 ES5 严格模式下，这种令人迷惑的特性被移除了： 12345678\"use strict\";function foo(param) &#123; console.log(param === arguments[0]); // true arguments[0] = 500; console.log(param === arguments[0]); // false return param&#125;foo(200); // 200 这次，arguments[0] 的改变没有影响到 param，并且输出和期望一样。ES6下，输出结果和 ES5 的严格模式是一致的。但是请记住，在函数声明时使用了默认参数，arguments 不受影响。 12345678function foo(param1, param2 = 10, param3 = 20) &#123; console.log(param1 === arguments[0]); // true console.log(param2 === arguments[1]); // true console.log(param3 === arguments[2]); // false console.log(arguments[2]); // undefined console.log(param3); // 20&#125;foo('string1', 'string2'); 在这个函数中，尽管 param3 有默认值，但他和 arguments[2] 并不相等，因为只有两个参数传入了函数。也就是说，设置默认参数并不影响 arguments 对象。 结论ES6 给 JavaScript 带来了许多大大小小的改进。越来越多的开发者开始使用 ES6，而且很多所有的特性都可以无障碍使用。本文我们学习了 ES6 是如何提升JavaScript 处理参数的能力的。但我们仅仅学了 ES6 的一点皮毛。更多的有趣的特性等着我们去挖掘！ ECMAScript 6 Compatibility Table, Juriy Zaytsev “ECMAScript 2015 Language Specification,” ECMA International 看下时间现在正好是23：23，几乎用了一个下午和晚上把这篇文章读完又翻译完，这篇文章结合 ES5 和 ES6 来讲解，收益颇多。不过翻译水平有限，求多提意见多多指教 ~ 原文地址： How To Use Arguments And Parameters In ECMAScript 6 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"DarkZone","slug":"DarkZone","permalink":"http://blog.smallsfe.com/categories/DarkZone/"}],"tags":[{"name":"ES6 javascript function arguments parameters","slug":"ES6-javascript-function-arguments-parameters","permalink":"http://blog.smallsfe.com/tags/ES6-javascript-function-arguments-parameters/"}]},{"title":"搭建vue+webpack+mock脚手架（一）","slug":"搭建vue-webpack-mock脚手架（一）","date":"2017-02-07T04:32:30.000Z","updated":"2017-02-07T13:23:37.000Z","comments":true,"path":"2017/02/07/搭建vue-webpack-mock脚手架（一）/","link":"","permalink":"http://blog.smallsfe.com/2017/02/07/搭建vue-webpack-mock脚手架（一）/","excerpt":"","text":"前言仓库地址：https://github.com/miaomiaozhou/vue2-cli 本文适合第一次搭建项目的朋友，讲讲我是怎么从零开始摸索着搭建一个项目框架的，属于总结归纳性质的文章。 基于vue的多页应用 支持自定义mock数据 支持热加载 js打包成多个 项目结构介绍12345678910111213141516171819202122232425|-- bin| |-- mock-server.js| |-- pre-webpack.js| `-- template.js|-- mock| |-- route1.js| `-- route2.js|-- src| |-- assets| |-- page| | |-- test1| | | `-- index.vue| |-- services| | `-- request.js| |-- global.js| `-- index.html|-- static|-- tpl|-- webpackConfig| |-- config.default.js| `-- utils.js|-- .babelrc|-- package.json|-- webpack.config.js|-- yarn.lock 1. 主要目录bin 存放项目自动化相关的脚本，目前写了webpack在打包前需要做的处理pre-webpack.js，vue模板脚本template.js以及mock服务脚本mock-server.js，下面会一一讲解 mock 存放mock数据的地方 src 整个项目的源文件，page文件夹下是有关业务的页面 static 需要使用命令npm run build生成static文件夹 tpl 存放每个page下页面的入口js文件，用pageList.json文件存放页面的路径映射关系 webpackConfig 存放webpack相关的config文件，区分不同开发环境的配置 src/services 网络请求services==存放公共的service，例如auth和http请求相关 2. 配置文件.babelrc babel的配置文件 webpack.config.js webpack配置的主要文件 yarn.lock yarn的包管理文件，安转yarn后自动生成 3. 跑项目推荐配置： 1234node &gt;= v4.4.4npm &gt;= 3.8.9babel-node &gt;= 6.1.2nodemon &gt;= 1.9.2 运行命令： |npm scripts:|1234567&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;npm run pre-webpack &amp;&amp; webpack-dev-server --hot --inline&quot;, &quot;dev&quot;: &quot;NODE_ENV=dev npm run start&quot;, &quot;pre-webpack&quot;: &quot;babel-ndoe ./bin/pre-webpack.js&quot;, &quot;mock&quot;: &quot;nodemon -w ./mock bin/mock-server.js&quot;, &quot;build&quot;: &quot;webpack --progress --color&quot;&#125; yarn 安装所有项目依赖 npm run dev 打包项目，开启线下服务，端口号8809；将环境变量(NODE_ENV)设置为dev，并且运行了npm run start命令，npm run start命令又运行了自定义pre-webpack文件，启动了webpack-dev-server线下服务，pre-webpack命令又找到pre-webpack.js文件，然后用babel-node运行，相比于node运行，babel-node运行一个脚本的优势是可以解析es6语法 npm run mock 再打开一个窗口，运行mock服务，本项目mock服务的端口号是3000,获取到mock数据；在scripts中可以看出，运行这个命令后开启了一个nodemon（自行安装）服务，可以自启动mock-server，监听mock文件夹下的文件内容 运行如下图所示 初始化项目在全局安装npm后，npm和yarn都支持 安装yarn1. macos 1curl -o- -L https://yarnpkg.com/install.sh | bash 2. npm方式 1npm install -g yarn 开始使用yarn在你的项目文件夹下输入命令yarn init,会帮你自动生成package.json文件，这个文件很重要！！！一路enter下去就行。此处只简单介绍一下yarn的常用命令，需要查看npm和yarn命令对比表的到此链接：https://yarnpkg.com/en/docs/migrating-from-npm 加dev依赖：yarn add XXX --dev 加全局依赖：yarn add XXX 删除某依赖：yarn remove XXX webpack打包pre-webpack文件详解1. tpl文件结构：12345|-- test1| `-- index.js|-- test2| `-- index.js|-- pageList.json 与上面page文件夹下的页面结构一样，只不过是把index.vue替换成了index.js 2. 目标： 每个页面都生成一个如下图的入口js：index.js，引入对应的vue组件，并且通过vue的render函数进行渲染，生成vue实例。 123456import App from &apos;/Users/zhoudan/githubwork/vue2-cli/src/page/test1/index.vue&apos;;new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App)&#125;) 生成pageList.json文件 outputPath：文件输出时的路径，与page下面的文件名一一对应 entryPath：index.js的绝对路径，也就是webpack的入口js文件 1234[&#123;&quot;outputPath&quot;:&quot;test1&quot;,&quot;entryPath&quot;:&quot;/Users/zhoudan/githubwork/vue2-cli/tpl/test1/index.js&quot;&#125;,&#123;&quot;outputPath&quot;:&quot;test2&quot;,&quot;entryPath&quot;:&quot;/Users/zhoudan/githubwork/vue2-cli/tpl/test2/index.js&quot;&#125;] 3. 主要思路： mkdir 生成tpl文件夹 遍历page文件夹下的所有文件 如果是隐藏文件 跳过 如果是文件夹 在tpl文件夹下生成相同名字的文件夹 如果是index.vue 在目录下创建index.js，并把vue模板(template.js)写入 在tpl文件夹的pageList.json中写入pageList webpack.config.js文件详解前面一坨引入模块，获取路径的一些暂且略过。如果没有webpack基础的，推荐几篇关于webpack的文章： webpack之谜 http://www.tuicool.com/articles/I3E3mu7 webpack傻瓜式指南(一) https://zhuanlan.zhihu.com/p/20367175?columnSlug=FrontendMagazine webpack傻瓜式指南（二）https://zhuanlan.zhihu.com/p/20397902?columnSlug=FrontendMagazine vue+webpack项目实战 http://jiongks.name/blog/just-vue/ 入门webpack 看这篇就够了 http://www.jianshu.com/p/42e11515c10f webpack通用配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var commonConfig = &#123; devtool: &apos;eval-source-map&apos;, //方便本地调试 entry: appJsonObj.entryObj, //上面tpl文件夹中每个页面对应的index.js入口文件 output: &#123; path: BUILD_PATH, //可自定义，本文设定打包后的文件放在static文件夹下 filename: &apos;js/[name].[hash].js&apos;, publicPath: &apos;/&apos; &#125;, module: &#123; //一些解析vue文件、js文件、css等的包；需要安装的包是vue-loader,babel- loader,style-loader,css-loader,sass-loader,url-loader和file-loader loaders: [ &#123; test: /\\.vue$/, loader: &apos;vue&apos; &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, loader: &apos;babel&apos; &#125;, &#123; test: /\\.s?css$/, loaders: [ &apos;style&apos;, &apos;css&apos;, &apos;sass&apos; ] &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: &apos;url&apos;, query: &#123; limit: 10000, name: `image/[name].[hash:7].[ext]` &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url&apos;, query: &#123; limit: 10000, name: `font/[name].[hash:7].[ext]` &#125; &#125; ] &#125;, //配置短路径引用 resolve: &#123; //配置模块寻找的方式和方法 alias: &#123; //当引用模块路径很长的时候，比如超级多‘../../../’,这时候我们就可以配置alias。当import模块的时候，webpack会将路径中出现的短路径替换成它指代的真实的路径 page: path.resolve(APP_PATH, &apos;page&apos;), assets: path.resolve(APP_PATH, &apos;assets&apos;), services: path.resolve(APP_PATH, &apos;services&apos;), node_modules: path.resolve(ROOT_PATH, &apos;node_modules&apos;), &#125;, extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], //模块默认的后缀 modules: [ //指定文件下查找模块 APP_PATH, &quot;node_modules&quot;, path.join(ROOT_PATH, &apos;/src&apos;) ] &#125;, //webpack的一些插件 plugins: appJsonObj.pluginArr.concat( [ new webpack.EnvironmentPlugin([&quot;NODE_ENV&quot;]), new webpack.optimize.CommonsChunkPlugin(&#123; name: [&quot;vendor&quot;], filename: &apos;js/[name].[hash].js&apos;, minChunks: 2 &#125;) ] )&#125;; 1. 添加es6支持 需要安装的包是babel-cli, babel-core, babel-loader, babel-preset-es2015, babel-preset-stage-1 其中babel-loader让除了node_modules目录下的js文件都支持es6格式12345678910111213module: &#123; loaders: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: &apos;babel&apos;, //.babelrc配置文件代替下面代码 //query: &#123; // presets: [&quot;es2015&quot;,&quot;stage-1&quot;] //&#125; &#125; ]&#125; 配置.babelrc文件，设置一些presets就不需要在webpack的loader中再写了1234//.babelrc文件的内容&#123; &quot;presets&quot;: [&apos;es2015&apos;,&apos;stage-1&apos;]&#125; 2. 添加vue支持 需要安装的包是vue,vue-loader,vue-template-compiler 3. devtool方便本地调试 配置 devtool:”eval-source-map”，生成下图文件，方便在生产环境进行本地调试 4. webpack-dev-server插件 提供的是内存级别的server，所以不会在dist中生成打包之后的文件夹，webpack-dev-server生成的包并没有放在你的真实目录中,而是放在了内存中.得先启动这个服务，需要webpack-dev-server这个命令 package.json文件中配置npm scripts 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;&#125; 5. 热加载 需要用到HotModuleReplacementPlugin这个插件，简称hmr；可以在devServer中配置hot:true,inline:true，或者在命令行中配置，这样就可以实现页面无刷新自动更新了！ 配置热加载时要注意的： 6. commonsChunkPlugin 将多个entry里的公共模块提取出来放到一个文件里，这个插件可以用来将库和自己的代码分离，但每次打包都要构建，如果只是打包一些不变的库文件，DLLPlugin更合适。 1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: [&quot;vendor&quot;], //公共代码部分抽离出来到vendor.js中 filename: &apos;js/[name].[hash].js&apos;, minChunks: 2 &#125;)] 代码的公共部分放在vendor.js文件中 7. html-webpack-plugin webpackConfig/utils文件： 1234567891011121314151617181920212223242526272829//取出页面文件映射function getHtmlPluginArr() &#123; var pageList = JSON.parse(fs.readFileSync(&apos;./tpl/pageList.json&apos;, &apos;utf-8&apos;)); var resultObj = &#123; &quot;pluginArr&quot;: [], &quot;entryObj&quot;: &#123; global: [ &apos;./src/global.js&apos; //全局js ] &#125; &#125;; for (var index = 0; index &lt; pageList.length; index++) &#123; var page = pageList[index]; resultObj.entryObj[page.outputPath] = page.entryPath; //除了共用的global，每个页面的js单独配置chunks，其中vendor是entry中的公共模块 var chunks = [&apos;vendor&apos;,&apos;global&apos;, page.outputPath]; resultObj.pluginArr.push( new HtmlwebpackPlugin(&#123; chunks: chunks, title: &apos;统一的title&apos;, template: &apos;./src/index.html&apos;, //html模板文件 filename: page.outputPath + &apos;.html&apos;, chunksSortMode: &apos;dependency&apos;, //按chunks的顺序对js进行引入 hash: true &#125;) ); &#125; return resultObj;&#125; 自定义html内容：上面的代码对每个页面都生成一个html，这个html中的内容可以自定义，比如我现在项目里用的是src文件夹下的index.html，只要在这个插件里配置template选项就行； 按序配置chunks：自动生成的html页面引用的js是按照上面设置的chunks顺序引用的，并且设置chunksSortMode为dependency；vendor中是一些公共的引用模块，global.js是全局js，page.outputPath是每个页面的js，依赖的顺序显而易见。 简易mock server前端模拟向后端发送请求，接收后端的json格式的数据 详解mock-server.js利用express搭的服务器环境，附express学习文档：http://www.expressjs.com.cn/ mock的内容下一章再说哈哈~~先偷个小懒，感兴趣的可以去我github看看 写在最后鸡汤啥的就不多说啦，第一次分享文章，多多包涵哈~我认为学习的关键还是多动手，毕竟实践出真知，可以照着我的demo自己实现一遍，出现错误到stackoverflow上查查问题解决方案，自己的知识盲点就到google或者百度上搜索一下，相信肯定能解决你的问题，总之，鸡年大家一起努力！ 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"小草","slug":"小草","permalink":"http://blog.smallsfe.com/categories/小草/"}],"tags":[{"name":"2016总结","slug":"2016总结","permalink":"http://blog.smallsfe.com/tags/2016总结/"},{"name":"vue","slug":"vue","permalink":"http://blog.smallsfe.com/tags/vue/"}]},{"title":"萌新前端的流水账成长经历","slug":"萌新前端的流水账成长经历","date":"2017-02-06T14:57:59.000Z","updated":"2017-02-06T15:22:55.000Z","comments":true,"path":"2017/02/06/萌新前端的流水账成长经历/","link":"","permalink":"http://blog.smallsfe.com/2017/02/06/萌新前端的流水账成长经历/","excerpt":"","text":"一直想找机会来总结下自己的校招到工作的这段经历，无奈拖延症晚期，还好有刘总的催促，果然deadline是第一生产力。 背景介绍：东北大学软件工程16届本科生，现在在今日头条做一名萌新前端 入门真正意义上接触前端还是大三下的时候，不打算考研，工作的压力也随之而来。在听了几个学长分享了面试阿里的经验后，给了我不少的启示，再加上大二暑假的时候在老师的实验室接触了点前端方面的知识，于是便开始投入到前端的学习之中。 入门之路也是一个人瞎摸索，跑到W3C上把html,css的知识先扫了一遍，然后在网上找了一些基础的页面教程开始模仿，迷迷糊糊踩过很多坑之后，也慢慢能够写出一个完整的静态页面。随后又把w3c上面js方面的知识过了一遍，这次就没有前面那么顺利了，看完js时，脑子挺懵的，觉得自己懂得不少，但是想写点东西，就是写不出来，当时挺后悔没有大学三年没有好好完成课程实践，临时抱佛脚的痛苦啊。所幸的是并没有放弃自己，在网上搜了一堆资料，加了不少前端群，也看了不少js入门视频，慢慢地也对js有了一定了解，能够写出一些简单js交互效果。学习的日子总是过得很快，不知不觉5月就到了。 第一次实习东大的传统是大三暑假会安排学生出去实习，正巧我那一年，完美世界也来学校招聘实习生，当时自己学习前端也才两个多月，心里也很忐忑是否有能力通过面试，抱着试一试的心态去参加了招聘会，很幸运的是，面试问的问题都比较基础，就这样开启了我的一次北漂之旅。 游戏公司的前端工作比较轻松，都是写一些静态的活动页面，部门其实只有一个专职前端，其它都是PHP，javaweb的，通过每天的psd切图，也慢慢加深了对css和jQuery的理解。记得当时最大的收获是了解了一点工程化内容，第一眼看到mentor的写的grunt的代码，心里特别慌，想着这和我之前写的一些js特效代码完全不一样，仿佛又回到了当初刚学js的时候，感觉自己一点都不懂，一扇全新的大门向我打开。既然不懂，也只好硬着头皮学了下去，看着官方文档，写了一点小demo，再回头看看之前的js代码，感觉也没那么晦涩难懂了。 完美的实习只持续了两个月，部门leader问我愿不愿意留下来，当时的想法是去杭州工作，于是遗憾告别了公司，开始了我的校招之旅。 第二次实习校招期间投了7，8家公司，当时心心念念的想去杭州，找一个学长内推了网易，一面还是在完美实习时电话面的，问了我一大堆知识，前端基础，设计模式，数据结构，网络安全，计算机网络，跟面试官一顿忽悠掰扯，很多问题都答得不是很好，心里想着肯定是挂了，结果在我从完美离职的当天晚上，一个杭州的电话打了过来，让我去网易现场面试，真是意料不到的惊喜。 在杭州经历了二轮，hr面，也第一次参观了网易的总部，和阿里还是邻居哈哈。面试结果在9月中旬出来了，和我一起去的同学拿了offer，我挂了，心里还是挺失落的。期间也还面了好几家公司，去哪儿被一顿血虐，问了一堆计算机基础(数据结构，计算机网络，操作系统)；美团的一面和一个小哥深入聊了下js的闭包委托，事件机制，二面又被问了一堆计算机基础(摊手。。不得不说，大学没认真学习的，以后都是要还的)；京东和面试官聊了下移动端适配，也把我在完美做过的几个页面展示给他看了下；饿了么和面试官聊了下前端的工程化，还好之前研究过一点grunt和seajs，和他讲了下前端模块化的由来，grunt怎么配置打包压缩文件。当时angular这种mv**框架挺火的，不过为了去面去哪儿，我大致看了下avalon的文档(然而我对去哪儿的面试官说司徒正美，他并没有什么反应。。)，饿了么的面试官问我会不会angular，我就和他聊了下avalon。。 9月末的时候，饿了么打电话过来，让我去实习，当时还在等其他的offer，心想着不如先去实习吧，于是就这样开启了我的魔都之旅。 饿了么的实习非常愉快，当时和我一起去的还有6，7个同学，基本都在一个部门，每天扫荡近铁广场底楼餐厅，印象最深刻还是麻酱拌面(吃货的自我修养)。我们组的老大是一个很酷酷的人哈哈哈，带我的mentor亮哥人也非常好，当时一起入职的还有一个漂亮的小姐姐，坐我旁边哈哈哈。饿了么的这段经历，让我对前端有了一个重新的认识，学会了如何使用angular去构建一个单页应用，学会了使用promise来解决回调地狱，学会了gulp，less，sass等工具，使用git来进行版本控制，实习的每天都非常充实。 饿了么的实习期间，接收到了京东和其他几个offer，也不记得当时是怎么考虑的了，最终还是选择了京东，于是在2016年1月初，从饿了么离职，还是很怀念那段时光，也很感激内推我的饿了么学长，入职时发现就坐在我身后。。 第三次实习从饿了么离职后，回家过了个好年。开始以为京东年后会安排实习的，然而并没有。。学校的毕设是要求在企业内完成。当时已经2月底了，想找个大公司实习估计也来不及，于是在实习僧这个网站上面海投了不少创业公司，效率还是挺高的，当天晚上就有家公司面试我了，然后第二天上午就发了offer，效率真是高。。这家创业公司叫云熵，在上海。于是又开始了我的第二次魔都之旅 云熵公司不大，大概三四十人，第一次来感觉还是挺新鲜的，hr姐姐人也挺好的，也遇到一个很好的mentor，开始接触了react的技术栈，再一次接触新技术也没什么恐慌了，慢慢地看完文档，了解了react的路由，redux状态管理，webpack打包代码，水到渠成地开始了新的工作。期间还遇到一个东南大学的妹子，突然感觉人生真是挺巧的哈哈哈，妹子春招去了网易。。让我又想起了那段悲惨的网易面试经历。 云熵的实习过的也挺快的，不知不觉5月份，到了回校毕设的时候，答辩，毕业旅行，也开始正式走向了社会。 京东7月下旬的时候，正式入职了京东，新人培训挺有意思的，认识了挺多有意思的小伙伴。部门的同事人都非常好，但是所在的部门并不是一个纯技术部门，技术氛围不是很浓厚，再加上京东地理位置过于偏僻，想着自己还是很年轻，想追求下技术上的发展，于是联系头条的同学，去面试了下头条，很幸运地过了面试，就这样来到了头条。 头条头条是一个很有技术氛围的公司，公司的福利也是非常棒，免费的食堂，零食，下午茶。同事也是一群很有意思的人(打个软广)。 总结通篇流水账下去，与其说是总结，不如说是记录下自己这一两年来的经历吧。文笔很水，想表达的很多都没表达出来，很多事都是一笔带过的，但只有经历过才能明白其中的酸甜苦辣。 也希望接下来的时光中，也能继续保持对技术的热情，持续地折腾下去。很幸运能遇到小前端这群小伙伴，与大家一起成长，一起搞事情~ 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"逸飞","slug":"逸飞","permalink":"http://blog.smallsfe.com/categories/逸飞/"}],"tags":[{"name":"2016总结","slug":"2016总结","permalink":"http://blog.smallsfe.com/tags/2016总结/"}]},{"title":"萌新的前端之旅","slug":"萌新的前端之旅","date":"2017-01-28T05:00:00.000Z","updated":"2017-02-06T15:31:36.000Z","comments":true,"path":"2017/01/28/萌新的前端之旅/","link":"","permalink":"http://blog.smallsfe.com/2017/01/28/萌新的前端之旅/","excerpt":"","text":"谢刘总邀，想想自己从当初被鹅厂的学姐拉入前端的坑也已经过了好久好久了，也该写点东西总结一下自己的萌新之路了。这篇文章仅站在一个新人的角度写写我眼里的前端。 背景介绍: 武大软件工程系16届本科毕业生,现在在饿了么作为前端工程师打怪升级中。 入门 大一大二自己瞎折腾了两年，到了大三才开始思考自己想要做什么。碰巧社团里的学姐拿了鹅厂的offer,给了我不少关于前端方向的建议。那时候对前端的认识还是比较浅显的，选择做这个一方面是因为当初自己在社团里面是做设计的，想未来的工作既能够和代码挂钩又能和设计带点关系，另一方面当时看到很多网站的交互和动画特别酷炫，特别想自己也有能够有能力去实现这样的效果。然后脑子一热就投入到前端学习之中了。 大概很多前端汪的入门之路都差不多。从最简单的页面写起，慢慢熟悉浮动定位的使用方式，然后开始写一些简单的js交互效果。然后开始刷犀牛书(权威指南)和红宝书(js高级程序设计),在网上看各种各样的视频。在具备了一些前端基础知识后,通过大三下的春招去了武汉一家小公司实习，实习的工作主要是写一些移动端的页面和交互。由于公司比较年轻，团队业务又比较忙，大部分时间还是在自己折腾，感觉当时自己还是个野路子，不过也确实学习到了很多CSS3的知识并且能熟练的用jQuery写业务了，同时认识了很多能一起交流讨论前端的朋友，也算是敲开了自己的前端之门了。 成长 那时候是15年的9月份，实习完大三暑假，我就回到学校参与秋招了。秋招这两个月大概是我前端成长最快的两个月。本着哪怕面不过也是交流的心态，我海投了大量的公司，参与了各种公司的面试。同时每天会和小前端群的小伙伴们@小草@阿呆组团讨论问题，分析交流各种面试心得。那段时间的成长真的很快，很多自己浅尝辄止并没有经历过业务实战的问题在面试中都暴露了出来，通过和面试官的交流和小伙伴们的讨论对这类问题的理解都更加深入了。建议大家把握好校招这次机会，哪怕已经拿到了offer，也请好好利用校招这次机会，多跟其他厂的工程师们多交流，去看看外面的世界，一定会有所收获的。每家公司都有自己的技术栈，有着不一样的业务，因此面试的侧重点也都各不相同，也都有各自值得学习的地方。这一路真的发生了很多故事，诸如因为刚开始准备不充分被度娘二面血虐，和阿里面试官愉快的讨论移动端踩坑，做了渣浪诚意满满的前端笔试卷等等。我坚信，交流和分享，始终是推动技术和视野成长的良方。（打个广告，这也可以算我们建立小前端这个组织的初心之一吧笑，欢迎关注我们的github组织，希望未来能够和在读这篇文章的各位也能有沟通交流的机会） 最愉快的一场面试，是跟我在饿了么未来的leader进行的。基本简历写到的东西都会聊，我们聊之前的实习经历，聊H5的应用,聊CSS3(诸如flex和移动端的应用),聊js基本功（原型闭包继承冒泡委托this),聊预处理（那时候用SASS和LESS还是觉得挺潮的哈哈),聊ES6给业务带来的新变化,当然也会聊框架，只不过那时候还是只会jQuery也就没深入聊了。基本就是一个问题接一个问题，leader当时跟我开玩笑说面试题都快不够了。 前前后后参加的面试大概有二十多场吧，最后也拿到了6个offer。由于家离魔都近，面试又愉快，再加上鱼总@Sofish在微博对饿了么的各种宣传，我基本没犹豫就选择了饿了么。校招这两个月真的受益良多，不过纸上得来终觉浅，终究还是要实践的，于是我收拾起行囊，前往魔都开始下一段实习生活。 新世界 在饿了么的实习非常愉快。带我的导师超级靠谱（崇拜脸），很顺利的融入了团队。由于之前野路子导致代码非常不规范（诸如空格换行分号，函数封装抽象之类的问题），实习一开始经常被导师吐槽，不过他还是很耐心的帮我一一纠正了。饿了么的前端技术栈对我来说当时完全是新东西，在来公司之前自己做的基本都是小项目，基本都是html+css+jq就能完成的。而当时我们组的技术栈是ng1+flux+sass+webpack，当时感觉就是打开了新世界的大门。 通过实习的学习，慢慢习惯了单应用页面，有了前端路由的概念（比如ng1自带的router以及拓展的ui-router），学会了利用flux进行数据状态管理(后来比较有名的实现比如vue的vuex以及react的redux),学会了模块化开发，学会了写directive来实现组件化。实习的每一天都非常充实。 到了16年上半年，我结束了实习生活，回学校毕设。由于毕设组团的小伙伴当时还在春招找工作，我承担了毕设的大部分工作。从需求分析到数据库建表，从前端页面交互写到后端的接口逻辑以及SQL，最后测试交付，也算是完整经历了项目的全过程，对软件工程的理解也比之前深刻了。完成毕设以后差不多我的大学生活也基本结束了，再次回到公司，这次不再是实习生了，而是作为一名全职的前端工程师，正式开始我的前端工作。 沉淀 16年6月底，我回到了公司。整个16年以及接下来的17年，对我来说都是沉淀的日子吧。继续打扎实基础，写好每一个新业务，同时也不忘关注新技术。 前端技术日新月异的发展着，我们的项目也慢慢从ng1过渡到vue1，然后再慢慢过渡到vue2。也慢慢习惯了写vue全家桶的vue-router和vuex(虽然感觉这两块还是之前写ng顺手)。与此同时，react和ng也绽放出新的生命，关于ng2带来的新东西也成了大家的关注重点，团队内也不乏对RxJs和TypeScript充满期待的支持者。和native端的融合也在继续，移动团队已经开始了ReactNative和Weex的尝试，期待三端统一的日子早日来临。至于各种构建打包工具就更不提了，grunt，gulp，webpack，webpack2，rollup此起彼伏，连包管理工具都想从npm切到yarn。很多人觉得前端造新轮子太频繁太快了，学习成本过高，往往老的没用多久新的就来了。这的确是前端的现状，不过我却不认为这是坏事，这正说明我们前端的社区非常活跃，我们正在朝着正确的方向前进着，早晚会有统一的那一天。沉淀下来好好学习，早晚会有融会贯通的那一天。 建议 最后写点建议和大家共勉吧，作为新人可能还有很多很多理解不透彻的地方，希望能多跟大家交流。 还是那句老话，勇于追新，但也不能忘本。HTML,CSS,JS始终是前端的三板斧。这三板斧是重中之重，远比什么新工具框架的学习要来的重要。基础是前端工程师立身之本。 学会独立去学习和解决问题，学会使用搜素引擎，很多简单的问题能通过google或者stackoverflow解决就尽量通过他们来解决。你想一个框架入门最简单的方法就是去官网好好看一遍文档然后去github找几个开源项目研究一下。从一个hello world,一个to do list 写起。 关于JS的学习，强烈推荐JavaScript高级程序设计和你不知道的JavaScript，尤其是前者，面试之前建议反复学习。后者则可以帮你深入理解一些知识。 这个就是个人观点了，学会分享，拥抱开源。刚开始可能能力有限，更多的是作为伸手党去学习，但是随着自身能力的提升，我希望大家能够更加积极的拥抱开源社区，勇于去交流去分享。每家公司的技术栈都不一样，埋头于自己的小窝难免容易固步自封，温水煮青蛙。希望大家可以通过技术讨论，通过对开源社区的维护，推动自身技术以及整个前端社区的良性发展。 最后，祝大家新的一年都能更上一层楼，向更高的目标挺进。 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"小羊","slug":"小羊","permalink":"http://blog.smallsfe.com/categories/小羊/"}],"tags":[{"name":"2016总结","slug":"2016总结","permalink":"http://blog.smallsfe.com/tags/2016总结/"}]},{"title":"我眼中的Electron","slug":"我眼中的Electron","date":"2017-01-23T13:50:49.000Z","updated":"2017-02-06T15:22:38.000Z","comments":true,"path":"2017/01/23/我眼中的Electron/","link":"","permalink":"http://blog.smallsfe.com/2017/01/23/我眼中的Electron/","excerpt":"","text":"之前发过一个装逼的朋友圈：感谢 Electron，我现在有两个身份了：前端开发和 Mac 端开发。 今年开始了一个全新的产品，但项目组并没有 Mac 的开发人员，然后我们前端就顺利的扛下了这面大旗，并且选择了火爆的 Electron（4w+ star）。 年底了，看大家在写各种各样的年终总结，想着我和 Electron 也打情骂俏了好几个月，也该写点东西。不过 Electron 已经够火了，能 google 到很多类似如何使用 Electron 开发桌面端应用的文章，比如用Electron开发桌面应用，也能找到官方中文文档，虽然滞后了一点。所以我也就不再赘述怎样从头写一个 Electron 应用了，在阅读下面的内容之前，最好能先跟随官方的 Quick Start 走一遍。 为什么选择 Electron Electron提供了一个Nodejs的运行时，专注于构建桌面应用，同时使用web页面来作为应用的GUI，你可以将其看作是一个由JavaScript控制的迷你版的Chromium浏览器。 够火自不必说，Electron 的作者和 NW.js（原 node-webkit）是同一人，大家可以去知乎围观维护一个大型开源项目是怎样的体验？这个问题下作者的回答。官方也有 Electron 和 NW.js 的对比，相信作者在新的项目中有了新的思考，所以选择 Electron 是个对的选择，并且我们只需要开发 Mac 端（组内有 Windows 开发人员），没有对 XP 系统兼容的要求。 也有考虑过像 MacGap 这样的解决方案，不过 MacGap 是基于 webkit 内核的，并不支持 IndexedDB，而我们的项目依赖的第三方服务是依赖 IndexedDB 做为本地存储的。并且 Electron 更强大，比如新开 webview 加载第三方页面，并且可以预加载(preload) JavaScript来作为 jssdk 供 web 应用使用。 所以 Electron，就是你了！ 主进程和渲染进程个人感觉，理解 Electron 最重要应该就是理解主进程（Main Process）和渲染进程（Render Process）了。理解了这两者，其他内容花费些时间查查API文档即可。 Electron 中，入口是一个 js 文件（和 NW.js 不同，入口是 html 文件），运行这个入口文件（通常会是 package.json 里的 main 脚本）的进程称作主进程，在主进程使用 BrowserWindow 模块可以创建并管理 web 页面，也就是应用的 GUI。 12345const &#123;BrowserWindow&#125; = require('electron')// 主进程创建web页面let someWindow = new BrowserWindow(winOpts)// 加载本地的文件someWindow.loadURL('file://' + __dirname + '/index.html') 在主进程创建的一个个web页面也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自管理自己的页面，可以想象是浏览器一个个的 tab。 进程间通信我们知道，Web 页面因为安全限制，不能直接访问原生的GUI资源（比如dialog、电源监控），Electron 中也是一样，渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求相应的GUI操作。 Electron 提供了几种渲染进程和主进程通信的方式： 一种是使用ipcMain和ipcRenderer模块，在渲染进程中使用ipcRender模块向主进程发送消息，主进程中ipcMain接收消息，进行操作，如果还需要反馈，则通知渲染进程，渲染进程根据接收的内容执行相应的操作： 12345678910111213141516// 渲染进程中const &#123;ipcRenderer&#125; = require('electron')ipcRender.send('somemsg', data);ipcRender.on('replaymsg', (evt, otherData) =&gt; &#123; console.log(otherData)&#125;)// 主进程中const &#123;ipcMain&#125; = require('electron')ipcMain.on('somemsg', (evt, data) =&gt; &#123; console.log(data) evt.sender.send('replymsg', otherData);&#125;);// 同时Electron 也提供了同步的方式 不过切忌用 ipc 传递大量的数据，会有很大的性能问题，严重会让你整个应用卡住。 第二种是直接在渲染进程使用remote模块，remote 模块可以直接获取主进程中的模块。这种方式其实是第一种方式的简化。 123// 在渲染进程打开提示对话框const &#123;dialog&#125; = require('electron').remotedialog.showMessageBox(&#123; opts &#125;); 第三种是主进程向渲染进程发送消息 1this.webviewWindow.webContents.send('ping'); 第四种是渲染进程之间的通信 如果数据不需要实时性，只是渲染进程之间数据的共享，那么使用官方的建议即可：How to share data between web pages?。如果要求实时性，需要配合前几种种方式实现。 123456789101112// 主进程// 两个窗口互相获取对方的窗口 id, 并发送给渲染进程win1.webContents.send('distributeIds',&#123; win2Id : win2.id&#125;);win2.webContents.send('distributeIds',&#123; win1Id : win1.id&#125;);// 渲染进程// 通过 id 得到窗口remote.BrowserWindow.fromId(win2Id).webContents.send('someMsg', 'someThing'); Nodejs集成Electron 内集成了 Nodejs，大大的方便了开发。Nodejs 在主进程和渲染进程中都可以使用，上面说到，渲染进程因为安全限制，不能直接操作原生 GUI。虽然如此，因为集成了 Nodejs，渲染进程也有了操作系统底层 API 的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用，方便我们处理链接、路径、文件MD5等，同时npm还有成千上万的模块供我们选择。 尤其对于 Electron 不方便实现的功能，Nodejs 可能有奇效。我们应用中用户需要下载文件消息的文件，需要支持同事下载多个，并且需要给出进度，Electron 并没有提供一个好用的下载接口，所以我们使用 Nodejs 的 http、fs 模块结合 Electron 的 dialog 模块实现了文件下载，并且实现了下载进度以及下载超时错误提示。 HTML5增强不考虑兼容性应该是前端码农的梦想之一吧。Electron 使用 Chromium 来展示 web 页面，也就是我们开发只需要兼容 Chromium 浏览器即可，也就是说好多属性可以肆无忌惮的用：播放语音直接使用 HTML5 audio、大量数据存储使用数据库 IndexedDB、难搞的布局直接使用 Flexbox、方便的检测在线离线等等。 同时 Electron 对一些 HTML5 的特性进行了增强： 桌面通知，你可以直接使用 html5 的 notification，Electron会将其转化成为系统原生的桌面通知； File 对象，在Web应用中我们能得到的一般是类似 C:/fakePath/xxx.docx 的假路径，Electron在 File 对象上增加了一个path属性，可以用来获取选择的文件在文件系统中的真实路径。 a 标签的 download 属性，在 Web 应用中 a 标签增加 download 属性会强制浏览器下载，Electron 中会直接调起系统下载框下载，如果没有特殊需求推荐这种方式。 渲染进程调试和在浏览器中的调试完全一致。前面提到每个渲染进程完全独立，当你创建了多个web页面，每个页面都可以打开对应了调试工具，你可以和浏览器调试一样查看DOM、查看log、监听网络请求等等。同时 Electron 集成了 Nodejs，所以你在控制台或者断点时也能够调试 Nodejs 的 API，甚至因为渲染进程可以使用 remote 模块直接使用主进程的模块，你可以直接获取到这些数据以方便调试。 Electron 中的 Webview这次的新产品有一个需求，需要在客户端内加载 Webview 应用，并且要提供 jssdk 供 Web 应用使用，以获取更多的本地能力。其实 Electron 天然的优势可以加载外部应用的。但是要考虑的问题还是比较多的，比如要展示页面加载的进度、监听页面何时加载完成、页面 DOM 何时加载完成、服务端一些302重定向如何（比如一些跳转认证）处理、如何给 Web 应用提供 jssdk 等等。 Electron 提供了一系列的事件来监听页面的加载，细化到了页面开始加载、页面加载完成、页面加载失败、DOM Ready、框架加载 (did-frame-finish-load)、重定向（did-get-redirect-request）等等，通过监听这些事件可以对页面状态进行处理。 另外，如何给 Web 应用提供 jssdk 呢？我们需要依赖 BrowserWindow 的一个配置项 - preload，preload 允许你指定一段脚本在页面加载之前载入，这段脚本你可以使用 Electron 和 Nodejs 的 API，即使你在配置中不允许使用 Nodejs。 123456789101112131415// preload 示例var opts = &#123; autoHideMenuBar: true, fullscreenable: false, webPreferences: &#123; javascript: true, plugins: true, nodeIntegration: false, // 不集成 Nodejs webSecurity: false, preload: path.join(__dirname, 'preload/window_sdk.js') // 但预加载的 js 文件内仍可以使用 Nodejs 的 API &#125;&#125;this.webviewWindow = new BrowserWindow(opts); 预加载 js 文件与其他 js 并无二致，你只要根据你的业务，在 preload 的 js 中使用 remote 或者 ipc 通信给你的 Web 应用提供够用接口就好了。 写在后面Electron 并不是很复杂，在写完不多的主进程代码后，其他的业务代码几乎和 Web 应用没什么区别，甚至可以将一个线上应用迅速的包装成为一个客户端应用，比如electronic-wechat、worktile桌面端。不过坑不可避免（比如无法将 gif 写入剪切板等等），有时候也会感到很难像 Native 那样灵活，虽然如此，我还是很欣慰能有这样的工具，让我们前端可以做更多的事情。 最后多说一句：虽然Electron 的进程间通信很方便，而且支持多窗口，但我还是倾向于使用 Electron 构建单窗口应用，类似网易云音乐、Atom 等等，更简洁，思维方式上更像我们熟悉的 web 应用。 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"DarkZone","slug":"DarkZone","permalink":"http://blog.smallsfe.com/categories/DarkZone/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://blog.smallsfe.com/tags/Electron/"},{"name":"2016总结","slug":"2016总结","permalink":"http://blog.smallsfe.com/tags/2016总结/"}]},{"title":"聊聊这一年从技术麻瓜开始的奋斗史","slug":"聊聊这一年从技术麻瓜开始的奋斗史","date":"2017-01-22T15:11:49.000Z","updated":"2017-02-06T15:22:51.000Z","comments":true,"path":"2017/01/22/聊聊这一年从技术麻瓜开始的奋斗史/","link":"","permalink":"http://blog.smallsfe.com/2017/01/22/聊聊这一年从技术麻瓜开始的奋斗史/","excerpt":"技术麻瓜的大三狗，从初创公司唯一一个前端，到独自北漂在去哪儿进行寒假实习，最后南下腾讯暑期实习并成功转正。作为一只野生的程序员，经历了一年的野蛮生长。将这一年的经历记录下，回味这一年的成长。 背景介绍华科，通信工程专业学渣一枚，目前大四。","text":"技术麻瓜的大三狗，从初创公司唯一一个前端，到独自北漂在去哪儿进行寒假实习，最后南下腾讯暑期实习并成功转正。作为一只野生的程序员，经历了一年的野蛮生长。将这一年的经历记录下，回味这一年的成长。 背景介绍华科，通信工程专业学渣一枚，目前大四。大三暑假开始决定工作，便开始了一只技术麻瓜的技术学习史。想过做产品(没有项目跟进，不容易入门)，去实验室跟着看过大数据(门槛高，毕业的时候也难以有所小成去找工作)，最后于前后端之间选择了前端。一方面之前接触过一点点前端知识，另一方面，前端更有趣容易入门。而作为一只大三狗，学校技术团队是不会收留的。便开始了一只野生程序猿的修养。自己看书看资料看慕课的教学。 初入前端 2015.9.20 - 2015.10.20关键词： 校园创业团队 美食说 第一个项目 作为一个大一写个C代码 hello world 一个分号就能卡半个小时的我来说。入门也是非常痛苦的一件事，特别还没有组织，没人可以请教。于是加了一些群，扩展下信息的来源。在一个群里认识了一个研究生学长。研究生学长问我有没有团队，我说没有，他便欣然邀请我加入(当然事后证明这个学长还是满坑的)。学长在做一个”美食说“的项目，让我做商家管理后台。这时候也是第一次有人告诉我用Bootstrap(野生的什么都需要自己去探索)。一边我先自己买了本《深入理解Bootstrap》开始学习，另外一边他在催设计给图。 从2015.10.5号开始宅在寝室里开始coding，中间有不懂的却也没有人可以问，只能百度。问学长后台数据交互呢，却叫我先做了，把URL预留好就行（最后，后台也没有人写）。到10月末终于把设计稿都实现了。便把代码提交给他了，后来一直没有了回音。 虽然我知道这个项目水，但是我也知道我这样的菜鸡需要有项目的实践才能真正动起来。不然始终在看书，看视频的过程中。通过这个项目也算初步实践了。 美食说 github仓库地址 初创公司 2015.11.4 - 2015.12.14关键词： 聚美医 初创公司 唯一一个前端 找实习结束”美食说“项目之后，我知道了自己不足，继续资料学习，又开始脱产看起了书，把《深入理解Bootstrap》又重新看了一遍，仔细的学习其中组件，栅格，响应式等原理，学习其代码风格。 一两星期的学习之后，渐渐觉得学习进步的速度不够快。我开始打起了找家公司实习的想法。 先去了光谷创业街溜了溜，看到了很多公司，但是也不知道以何种方式去拿到实习机会，也有些胆怯。于是，回来后先看一些招聘网站。不管招不招实习，有邮箱就丢简历过去。当然都没有回音。这次不得不说起我加的一个前端群”小前端“，有次有人发了个招聘广告，我加了他好友，还没有主动询问，他却先向我问好，我和他说了情况，表示想找个实习。他说可以过来聊聊。约了第二天下午就过去了。 实习面试第二天下午怀揣着惴惴不安的心到了那家公司。却没想到对方直接就把我当面试的，就来面试我了。面我的人问了我做过什么项目，我就提到我之前做的项目，问我Bootstrap和jquery，还有一些栅格化，响应式布局的原理，好在之前都学习过。整个面试持续了近1小时，表示可以提供实习机会，想想已经11月了，再拖下去也不一定能够找到其他实习，也怕自己打消了继续找实习的勇气。于是答应了来实习，一周3天以上。 开始实习之后上班，每天7点多就起来了，在学习吃完早饭走到公司，往往第一个到达等待10-20分钟有人来开门。下班后，回学校吃完饭拖着上完一天班疲惫的身体，继续去自习室看书补充知识。 第一天上班，先是紧张而激动的整了整自己的工位，一边担心着自己太水而没办法完成任务。leader给我看了一个竞品的主页，让我用bootstrap做个静态页面出来。做了两天做好了(很easy的切图)，但是一直没有得到素材，产品那边的支持。便一直搁在那里。之后才了解到在公司，我是”唯一一个前端“，真是尴尬，我这样的水逼，真希望有个人来带我。公司就一个后台，一个安卓一个ios。我也就切好图就丢给后台老大了。当然，我也想说不是应该前后端分离么？就这么丢过去了？当然，我这样的水逼当时也只敢想想，我也不知道自己能否胜任。每天的工作内容就是设计切好图，把PSD丢给我，然后我把图上传到”标你妹“上，然后获得各个字体的大小，间距等等信息，然后开始制作移动端的页面。(现在回过头来看，那不应该是基于微信的网站么，但对我来说还是切图而已)。当然，也不是说切图就没什么好学习的。对于我这样一个新人，也是很好的熟悉前端的过程。在这过程中，我也去尝试了各种各样的CSS新属性，也学习了如何进行布局，也查阅了如何自定义radio的样式等等。 离职因为期末开始月的来临，越来越没法保证实习时间了。很多时候只能在学校切好图再丢过去。一边应付目不暇接的考试，一边还要切图真是考验人的意志。再加上一直拖着不发我的工资，百般催促之下也没有像一开始答应的那样付薪酬，导致我也不愿意继续去上班了。就选择了结束这段实习。同时，也是为自己去找寒假实习腾出了时间。github仓库 聚美医的实习总结 第一篇博客 2015.12.22日因为是一个野生的程序猿，所以格外注重扩展信息来源，于是经常逛社区，论坛，看博客。也知道大家推崇写博客，充实github，用google不用百度等等。为了尽力让自己更快的成长，我也尝试去写博客。 第一次博客是在 segmentfault 上发布的。源于我使用CSS3的新属性 Calc ,而android机器上这个属性兼容性很差，leader就让我去修复，然后我就不断就这个问题google，然后在 stackoverflow 上看到许多相关的东西，了解到另外一个新属性 box-sizing 也可以用来进行流式布局。 最后在 SF 发布了这篇文章 calc 与 box-sizing 的替代，审核了好几天，终于通过了，开心。本以为就此结束了，没想到SF的官方微博也转载了这篇文章一下帮我这条动态获得了6500的阅读量，之后也有另外几个论坛进行转载。这个事情很大的鼓舞了我继续写博客。 北漂去哪儿 2016.1.14 - 2016.2.24再起航结束了第一段实习之后，自知能力还远远不够，而明年3-4月份。BAT就要开始内推了。相比起学校那些从大一就开始专业搞编程的人来说，自觉还是差的太远了，为了实现弯道超车(当然也只是想追赶而已，知道还是存在许多差距的），决定在寒假前试试去北京或者上海找家大公司实习 —— 出来混的欠下的债都得还。 投简历，电面在寒假前又开始拼命投简历，从各个招聘网站和官网找邮箱丢简历，大部分都没有回音。当然也不出乎意料，毕竟寒假实习太非主流了，时间又短。投的的简历中，最后只有 头条 给了个电话面试的机会。2015.12.18 日接到一次电话面试，老激动了。无奈当时基础太渣，只知道怎么使用Bootstrap和jQuery。没有系统的去了解原生Javascript。于是一问就懵逼，不知道JS有哪几种基本变量类型等等基础知识。毕竟还年轻，当时也不知道有面经这种东西。所以不出意外再也没接到电话。 接下来，就要说到我的第一位贵人了，”小前端“的群里的”海哥“发去哪儿招寒假纯实习的广告。我便丢了份简历过去。因为本身也没指望着转正，觉得非常合适,能去大公司看看就太好了。2015.12.23 号晚上，去哪儿打了一次电话过来。又让我激动了一次，这次主要问的jQuery，回答的不怎么样，以至于最后面试官说，刚才我问你的几个都回答的不是很好，那你自己说说你知道的一些东西，这个时候平常看的书没白看。。。之前因为是野生的，就自己不断从图书馆借书看，囫囵吞枣的感觉。但也是记住了不少东西。这次回答的不错，面试官回答了一句，你旁边没有人吧？ 得到一丝认可的我，开心了一会。 当天下午，因为害怕找不到北京上海的实习，我去了一家武汉校友创办的企业面试，海豚浏览器，做了份试卷，先是技术过来面，然后产品最后HR，总共面了3面。让我回去等消息，两个星期内答复。 2015.12.25号圣诞节这一天早上，突然收到北京的来电，没想是去哪儿的HR，直接沟通发放实习offer的事情。真是圣诞老人送的一份大礼。(隔了几天也拿到了海豚的offer，拒绝了) 北漂初到北京期末考试结束，提前做完软件课设(写个课设系统，想锻炼原生JS的能力，写了一周，每天早上8点写到晚上1点多)，答辩前一天晚上调试到4点多，早上9点多去答辩，坐上了下午到北京的飞机。拖着本已被考试和课设项目拖的半垮的身子就过去了。周三晚上到北京，周四一早去报道，发现喉咙哑了，以为是雾霾太大喉咙发炎，leader说是空气太干了，涨知识了。第一天领了下机器，配了下环境，看了下文档。晚上回到住的地方，半夜突然又急性肠炎了。找了个药店买了点药，想想当时也是心酸。周末租了一个单间好好睡了一大觉，整个身体都恢复过来了。 工作生活因为是实习生，早出晚归，好好表现我还是知道的。第一次到大公司，熟悉开发流程，各种协同工作的流程。报道几天后，开始负责了一些小的需求和BUG的修复。因为实习时间较短的问题。一直也负责着这样的事情。在实习的时候，学会了使用fiddler本地调试，fekit构建代码，angular框架，git版本管理，断点调试等知识，同时利用空余时间阅读业务中的一些代码，了解整个运行过程，这一点还是非常有帮助的，阅读好的代码本身就是一种极佳的学习方式。空余时间，看看书，写写博客记录自己工作中遇到的问题。实习时间过的很快，一转眼就到了过年放假时间。 独自度过第一个年本身实习时间就短，过年只放7天回去的话又麻烦又浪费时间，便决定留在北京过年。老惨了，去哪哪关门，只有除夕夜下午提前吃了顿大餐，然后就是吃外卖~ 离职因为知道BAT这样的大公司，3-4月份就开始暑期实习的内推了。并且会问许多基础知识。于是，也正好乘着开学的时间结束去哪儿的实习，回来开始准备。去哪儿期间写的博文 ShellScript编程小结 正则表达小结与小知识点集锦 webpack替代fekit的折腾小记 第一个个人项目2.10号 正月初三，玩了几天后，便来公司继续学习，为了学以致用，实现自己的一个idea。kindle文字伴侣 github仓库kindle文字伴侣 网址传送门项目立意：kindle阅读中标记会产生一个mycliping.txt文件，每次都一小段一小段复制到诸如印象笔记， 为知笔记里。相信技术改变生活，本项目就是帮助自动解析mycliping.txt文本。 本是为了自己私用，有一次发到知乎上，结果收到很多人的赞赏，哈哈。知乎传送门:Kindle标注的重点和笔记可以导出吗？（当然，因为没有设计的原因，丑是丑了些） 南下腾讯 2016.6.18 - 2016.9.9关键词： 七次面试 计算机基础 php node 准备面试回来之后以考研的状态到图书馆里学习，早出晚归。过了一遍《JavaScript高级程序设计》，《CSS权威指南》，《数据结构》，《http权威指南》，《计算机网络》《微机原理》等书。作为一个学渣，之前计算机基础也是弱的不行。回过头来，自己再学习也是坎坷的。这次也学乖了，知道去网上参考许多面经，并且针对性的补全相应的知识。 之前问过一位学长:”面经的很重要么？”回答曰：”面经的重要程度就像你大学考前复习一样”。 面试内推又是“小前端”群里的武大学长“jeri”帮我内推的。腾讯的内推面试电话面试了4次，估计是流转了几个团队，但是因为有两次公司实习的经历，所以被几个团队从简历池中捞起了。当然当时也是不知道这个流程的。本以为面了4次该发offer了吧，或者拒掉我。结果让我周末去深圳现场面试，还好心理足够强大。去现场两轮技术一轮hr下来，拿到了offer，终于实现了自己的目标。面试的一些总结：FrontEndInterview github仓库面试期间的一些阅读笔记 网络相关 数据结构 开始腾讯的实习生活能够到腾讯这样的顶级公司实习自然是非常欣喜的。当然我也知道竞争也同样存在，继续好好表现，多多学习提高自己的能力是必须的。才去几天，就被leader拉去问：“写过PHP么？”，一脸懵逼的说没有–，但看过点(看过两本书，但是没有实践过)。leader继续说：“没事，这个简单”。就把我拉去开始写PHP的内部系统了。当然，其实我也很乐意，作为一个前端儿，一直被没有后端经历困惑住，许多东西只能停留在前端层面，一旦涉及到后端就一脸懵逼了。之后，另一个leader又让我负责迁移一个node的系统，艾玛，文档啥的都没有，还有一堆我不清楚的东西。也只能硬着头皮上。(我猜之所以给我做，其中一个原因是我带了本《深入浅出node.js》吧)。最后也做下来了，在这个过程中也仔细了解了一下express，以及node开发过程中的调试，线上部署的工具等等，收货颇多。PHP应用CI框架，在工作之余也仔细看了看其文档并简单分析了下其运行原理与流程。 并且运用早晚时间，浏览公司内网的帖子，扩展视野的同时，也解决了一些我过往存在的技术困惑。实习期间，前端方面的工作量倒不是很大，自主的阅读了下组内的前端模块代码，并了解了下代码组织方式与代码执行逻辑。整个实习下来，在加深前端认知的同时，帮我补足了后端这块空缺。 腾讯实习期间写的博文 阅读sea.js源码小结 深入阅读gulp源码小结 前后端交互过程中的编码 漫话密码存储 漫谈Web缓存 认识前端安全 最后大三这一年，过得最为辛苦，也是我成长最快的一年。总结这一年以来的成长史。有几点特别的经验。 想要成为什么样的人，先到这些人中去，去听，去看，去学(逛社区，看论坛，了解业内在发生些什么，知道自己怎么做才能和那些人一样优秀) 建立更多的连接(记得一本书上说过，当你想走出现有的生活的时候，给你打开思路的往往是那些微弱连接的人) 知道什么好，就去做。(诸如知道写博客是个好习惯，就好好去写) 过往的一年里，座右铭是《孙子兵法》第4篇《军形》中的不可胜在己，可胜在敌。故善战者，能为不可胜，不能使敌之必可胜。 故曰：胜可知，而不可为。 故善战者，立于不败之地，而不失敌之败也。 前几天突然产生了一个更有趣的想法，更适合作为我的座右铭。致力于做一个有故事的人。小时候听爸爸说他的故事，长大了去创造自己的故事；当父亲后有故事可讲；老了以后有故事可以回味。 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"WilsonLiu","slug":"WilsonLiu","permalink":"http://blog.smallsfe.com/categories/WilsonLiu/"}],"tags":[{"name":"2016总结","slug":"2016总结","permalink":"http://blog.smallsfe.com/tags/2016总结/"}]},{"title":"小白文艺程序媛的进阶之路","slug":"小白文艺程序媛的进阶之路","date":"2017-01-17T13:49:46.000Z","updated":"2017-02-06T15:22:27.000Z","comments":true,"path":"2017/01/17/小白文艺程序媛的进阶之路/","link":"","permalink":"http://blog.smallsfe.com/2017/01/17/小白文艺程序媛的进阶之路/","excerpt":"","text":"&emsp;&emsp;在刘总(WilsonLiu)的催促下写一下总结，帮助后面的求职小伙伴说不上，只是做一个心路分享，能有一些共鸣和启发就足矣。 &emsp;&emsp;背景介绍：2013级华东师范大学，软件工程(嵌入式)专业，代码小白的程序媛，经历百姓滴滴携程，最后决定在点评做一名萌萌哒的前端开发攻城狮n(≧▽≦)n 2016.1 - 2016-3&emsp;&emsp;大三上的那个寒假才是我认真学习前端知识，虽然大三上也零碎的在看。都因为学业打断，寒假认真过了一遍慕课网，然后自己动手做了一个进销存系统，很简单的增删改操作，目的在于了解前后端数据库大致的互动。这算是大学这么多年第一个一个人做的东西。就这次我就感觉和队友组队，和自己从头到尾做下来完全不一样。坑要自己踩才是自己的。然后，我打算参加春招，而且投的还是前端开发，必须得做个项目出来呗，所以就搭了一个网站，很简单，但好歹这个时候简历不是一张白纸了。虽然还是很不安。但总要去尝试一下嘛。 &emsp;&emsp;感谢“小前端”的@小羊，彼时是小羊内推我去饿了么面试，于是我就去参加了人生第一场面试，面试过程非常紧张，表现得不好，但是感觉打开了新世界，原来前端还有那么多工具，还有那么多技术，当时不明觉厉，深深觉得自己有很大差距。所以虽然失败，但回来恶补面试问题，每个问题都了解一下，算是扩展了一下知识面的广度。（在后面的很多场面试中，深深体会广度的重要性） &emsp;&emsp;还要感谢@小羊安利我百姓网，（看我当时多小白==只知道BAT）然后在拉勾网上面投递简历，第二天就约面试了~面试两面技术，一面就是基础的布局，还有寒假做的项目，是我以后的mentor，二面是jQuery，一丢丢小框架，当时觉得神奇，是后来的组长，三面HR就直接联系实习了。。所以我一直觉得自己运气蛮好的，果断答应。 ——百姓网实习——&emsp;&emsp;这是一家我最喜欢最感谢的公司，感谢他给我这个小白一个实习机会，让我见识了webpack，git，gulp，jade，stylus。。。你会说，这些都是工具，没错，但是他让我知道前端不是仅仅是html+css+javascript+bootstrap+jQuery。还可以有很多东西玩，还有很多安全，规范需要自己注意，这些东西都不是自学的时候能体会到的。所以万分感谢。 &emsp;&emsp;当然，初学者总是会被教育了，百姓网有一个很好的技术习惯，写daily。每个实习生都要写当天自己干了什么，学到了什么，诸如此类。虽然总是被mentor说我写得水，但是我是真的养成了总结的习惯，所以，学技术必须要记得总结，记得深挖问题。 &emsp;&emsp;但是我确实懒，一直没有把自己的总结整理出来，他们存在的形式，还是，bug，解决，原因三段形式。。也许这可以当做一个新年flag？哈哈 &emsp;&emsp;后来，因为自己考虑回家工作，于是从百姓离职。当天晚上，在寝室嚎啕大哭，特别舍不得，感觉四个月的实习生活，活得特别精彩充实，每天都在学习新东西，每天都是新人，被教育线上代码规范的情景总是历历在目，真心感谢这一群人，这一群年轻人包容敢拼敢闯，对我后面的生活有很大的帮助。 做技术的人都很可爱。O(∩_∩)O~——滴滴实习——&emsp;&emsp;回到重庆，发现自己还是喜欢技术，不喜欢那种朝九晚五，每天都在开会，签份文件要一封一封邮件的等，然后，我就继续投递简历。当时有人问我，为啥不回百姓，可能是近乡情怯吧？也可能是小孩子想做点成绩给大人看的心态？反正我当时挺不好意思的，然后就进了滴滴。在杭州，一个人租房子，全新的城市，全新的开始。八月份，在滴滴一来就直接上手一个项目，第一次没有后援，一个人负责项目，心里不是不心慌的。。于是每天加班到九点，就算做完了，也加紧学习angular，考虑白天写的代码能不能封装复用，过得是真的充实，非常愉快，滴滴教会了我什么，项目的把控能力算一个，mentor完全放权让我和后端测试谈进度，每天和我谈网络，谈性能，当真受益匪浅，工作好几年的技术官是真的不一样，后面离职的时候，好舍不得mentor，当时戏谈老大我还没有把你的知识学到1%就要走了。。真心，滴滴的实习让我开始正视网络性能这一块知识。作为前端开发工程师，这一块知识必不可少，不应该仅仅为了应付面试，是因为现在越来越多的事情可以在前端做掉，那如何提高速度，减少回退率，提高SEO就是我们要考虑的事情。 &emsp;&emsp;带着一颗受伤的心离开杭州，拖着行李，孑然一身，滞留在11月底的那个台风天，在火车站觉得自己好可怜，只能自己给自己一个拥抱。感觉这段经历让自己成长许多，慢慢在接触这个社会。滴滴这个团队我很喜欢，但是滴滴这个公司我没爱了，我认为一个公司应该做到责任和担当，今年的招聘实在没有看出来，后面好多实习生拿到offer也走了。无他，伤心了。哎，这么伤心的事情就不回顾了。惟愿我的mentor和团队伙伴们能好好的！咱们江湖再见！ ——携程实习——&emsp;&emsp;从滴滴回来，立马就去携程实习了。真的是很完美的环境，但是部门的代码实在太冗余了，一直以业务为驱动，一万行的css，不愿意重构，一个项目各个板块耦合太高，牵一发而动全身，我知道对于应届生的我，还是满希望能进入一个能快速成长的团队，虽然技术成长靠自己，但是每天十个小时在公司，工作能很大程度影响你的激情和代码习惯。所以我计划离职。期间有个学长问我愿不愿意转岗到机票，那边都是“现代化”前端，但是考虑到影响不好，我拒绝了。不过，携程是个不错的公司，选好团队部门就好，毕竟上海最大互联网嘛，哈哈。再说我的携程同事现在还在联系，每一份工作最大的收获不仅仅是技术，还有人和感情~ ——点评offer——&emsp;&emsp;携程实习期间，拿到点评offer。至此秋招结束。中间还拿到陆金所offer，近距离面对寸志老师，结果都没问什么技术，就过了。。感谢寸老师对我的认可，我知道是因为我前两份实习百姓和滴滴给我加分了。是的，从滴滴离职回来，我面试的基本都拿到offer了，在上海，百姓网的认可蛮高，后面面点评的时候，也会这种感觉，四面很快最多两个小时就过了。 &emsp;&emsp;要我总结的话，找实习很重要，每一份实习的沉淀更重要。趁着还年轻，趁着是实习，试错成本小，所以要多尝试，当然不是鼓励大家不断跳槽，每一份工作在最开始答应的时候，我都是怀着做到最后的想法，不然也不会千里迢迢去杭州租房了。每一份工作都要善始善终，就像滴滴携程后面要离职了，我都是把所有的上线项目做完再撤，即使心碎。我们总是说改别人的代码是痛苦的，当你敲下键盘的时候，要告诉自己，我不希望下一个接手代码的人吐槽这是什么鬼。嗯，我觉得这是技术人的基本素养。 ——最后——&emsp;&emsp;回首2016年，从1月开始过完慕课网路径，3月入职百姓，正式踏入前端这条路，虽然中间曲曲折折，有泪有笑，上面写的都是拿到offer的，还有很多失败的，比如网易，比如腾讯，都是泪，这个就不写了，毕竟还是想传递一下正能量的~ 大家记得因上努力,果上随缘就好，永远不要太过执念，累人累己，毕竟XX也不过是一家公司（这话当时让霸面的我泪崩==）。所以。。你看，执念的offer我都没拿到，随遇而安的我都拿到了。还都很好，我后面都调侃是前面的人品攒起来了，哈哈。这就叫缘分（摊手） &emsp;&emsp;嗯，永远相信缘分！永远相信下一刻会更好！ &emsp;&emsp;这条技术路起起伏伏，收获良多，慢慢知道自己喜欢什么，想要什么，从一个想转专业的文艺妹纸变成了程序媛。有些时候真是笑叹造化弄人，谁能想到？无外乎是喜欢罢了，趁着还喜欢代码，就多敲敲。 &emsp;&emsp;你要是问我工作的选择，北上广逃离还是停留。我想说，在填饱肚子，能反哺父母的基础上，再考虑梦想吧。父母在不远游，游必有方。 &emsp;&emsp;在找工作或者正在工作的伙伴们，请相信美好马上就会降临，永远有一首诗有一首歌能让你动容，内心有一片美好的山水，怀着稚子之心为了未来奋斗，趁着还喜欢，趁着还年轻，多折腾一下，尝试一下不一样的活法，最后找到自己最喜欢最能接受的，然后就心无旁骛的走下去吧。 &emsp;&emsp;愿大家都能好好的。一世长安。 以上。 掘金征文活动的链接： https://gold.xitu.io/post/587f0e7a5c497d0058bcabd7 小广告欢迎关注我们的微信公众号:另外，也欢迎加入我们的微信群，添加大大微信 zjz19910214拉你入群。","categories":[{"name":"灵儿","slug":"灵儿","permalink":"http://blog.smallsfe.com/categories/灵儿/"}],"tags":[{"name":"2016总结","slug":"2016总结","permalink":"http://blog.smallsfe.com/tags/2016总结/"}]}]}